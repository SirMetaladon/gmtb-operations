@name Operations v1.42
@persist HID TargetCarcount PlaceholderID UniqueCommandID TT Xt XALL CurrentCarcount StoredCarcount BlockIncrX TEC
@persist [MainEntityList Tracks CarsCreatedByCommand Router ToSendOut WorldMarks Adder CommandStack CarspawnerCommandStack Default R2 Segments RouteKey Routes JobsActive JobsStored CarsAvailable CarsReady ToEvaluate Trains BlocksOK CardsCreatedByCommand]:table
@persist [Era HoldState]:string
@persist [Stock LocsToMark Interchanges Ktr WorldMarkEnts SortedTimers CarsToScan CarsToHold LocationKeys CheckDeletions]:array

@outputs CurrentCarcount CommandStack:table XALL JobsActive:table SortedTimers:array HoldState:string CarsToHold:array CarsToScan:array TEC

@inputs Response Reload:table IncRel
@persist Inc Signal:table SignalStorage:table
@outputs Inc Signal:table SignalStorage:table
@outputs MainEntityList:table
@trigger none

@model models/props_lab/servers.mdl

if(first() | dupefinished()){
    
    
    ####SETTINGS#############################################################

    Era = "1980s" #Set the Era string here. Use the same names as the Carspawner would.
    
    #Configuration file for the map
    
    ##include "opsconfig/ssg_phx_jobs"
    #include "opsconfig/ssg_rsg_jobs"
    ##include "opsconfig/lober_jobs"
    ##include "opsconfig/ssgrsg_test"
    
    ####END_SETTINGS#########################################################
    
    
    #JOB CLEANUP CODE - can't be moved else E2 will whine
    local KJ = Segments:keys()
    local TestColors = array()
    
    for(X = 1,KJ:count()){
        
        J = KJ[X,string]
        
        if(Segments[J,table]["color",vector] != vec(0)){
            
            Segments[J,table]["color",vector] = clamp(Segments[J,table]["color",vector],vec(0),vec(255))
            TestColors:pushVector(Segments[J,table]["color",vector])
            TestColors:pushString(Segments[J,table]["name",string])
            
        }
        
    }
       
    local KJ = Tracks:keys()
    
    for(X = 1,KJ:count()){
        
        J = KJ[X,string]
        
        if(Tracks[J,table]["color",vector] != vec(0)){
            
            Tracks[J,table]["color",vector] = clamp(Tracks[J,table]["color",vector],vec(0),vec(255))
            TestColors:pushVector(Tracks[J,table]["color",vector])
            TestColors:pushString(Tracks[J,table]["name",string])
            
        }
        
        if(Tracks[J,table]["work",array]:count() & !Tracks[J,table]["time",number]){
            
            Tracks[J,table]["time",number] = IndTurn
            
        }
    
    }    
    
    #variable delarations to get the server to shut up
    Router = table()
    SignalStorage = table()
    ToSendOut = table()
    Stock = array()
    HID = 0
    
    ### Functions
    
    function vector newabs(V:vector){
        
        return vec(abs(V:x()),abs(V:y()),abs(V:z()))
        
    }
    
    function string swap(S:string){
        
        if(S:find("empty")){
            
            return S:replace("empty","loaded")
            
        }else{
            
            return S:replace("loaded","empty")
            
        }
        
    }
    
    function number boxed(V1:vector,V2:vector,V3:vector){
        
        #If V3 is within max V1 and min V2, return 1.
        
        if(V1:distance(V2) > 0){
        
            return ((V1:x() >= V3:x()) + (V1:y() >= V3:y()) + (V1:z() >= V3:z()) + (V2:x() <= V3:x()) + (V2:y() <= V3:y()) + (V2:z() <= V3:z()) == 6)
            
        }
        
        return 0
        
    }

    function number within(V:vector,S:string){
        
        #S is the location code for the current target location
        
        local CX = Tracks[S,table]["boxhi",vector]
        local CN = Tracks[S,table]["boxlo",vector]
        
        local R = Tracks[S,table]["boxrot",number]
        
        
        local V2 = V:rotateAroundAxis(vec(0,0,1),R)
        
        return boxed(CX,CN,V2)
        
    }
    
    function number distrand(N,D){
        
        return 1
        
        return floor(N-random(0,N^D)^(1/D))+1
        
    }
    
    function increment(T:table,S:string,N){
        
        T[S,number] = T[S,number]+N
        
    }
    
    function startEntityIDTimer(S:string,N){
        
        entity(S:toNumber()):setCarTagColor(vec(220))
        
        if(N != 0){
    
            #Relative to the System Time, in seconds
            TimerEnd = systime() + max(Tracks[MainEntityList[S,table]["route",array][MainEntityList[S,table]["step",number],string]:explode("|")[2,string],table]["time",number],0.01)*60 #original time is in minutes
            
        }else{
            
            TimerEnd = systime()
            
        }
        
        MainEntityList[S,table]["timer end",number] = TimerEnd
        
        local Index = 1
        
        while(SortedTimers[Index*2,number] < TimerEnd & SortedTimers[Index*2,number]){
            
            Index++
            
        }
        
        SortedTimers:insertString(Index*2-1,S)
        SortedTimers:insertNumber(Index*2,TimerEnd)
        
        
    }
    
    function number safe(){ #Function that determines if the current iteration is out of processing time
        
        return minquota() > 1000
 
    }
    
    RouteKey = table()
    Routes = table()
    
    
    function array route(Start:string,End:string){
        
        if(RouteKey[Start+" "+End,array]:count()){
            
            return RouteKey[Start+" "+End,array]
            
        }
        
        if(Tracks[Start,table]["area",string] != ""){
            
            TrueStart = Tracks[Start,table]["area",string]
            
        }else{
            
            TrueStart = Start
            
        }
        
        if(Tracks[End,table]["area",string] != ""){
            
            TrueEnd = Tracks[End,table]["area",string]
            
        }else{
            
            TrueEnd = End
            
        }
        
        if(TrueStart == TrueEnd){
            
            return array("0|"+TrueStart+"|0","loc|"+End+"|local")
            
        }
        
        
        local Seen = table()
            
        Heap = array(TrueStart)
        
        local Xplor = "0|"+TrueStart+"|0"
        
        while(Heap:count()){
            
            local A = Xplor:explode("?")
            local B = A[A:count(),string]
            local C = B:explode("|")[2,string]   
            local Add = Routes[C,array]
            
            for(X = 1,Add:count()){
                
                local New = Add[X,string]
                
                local Next = Xplor+"?"+New
                
                if(New:explode("|")[2,string] == TrueEnd | New:explode("|")[2,string] == End){
                    
                    N = Next:explode("?")
                    RouteKey[TrueStart+" "+TrueEnd,array] = N
                    
                    if(New:explode("|")[2,string] != End){
                        local Final = N[N:count(),string]:explode("|")
            
                        Final[3,string] = "final"
                        Final[2,string] = End
                        N:pushString(Final[1,string]+"|"+Final[2,string]+"|"+Final[3,string])
                        
                    }
                    
                    return N
                    
                }
                
                if(!Seen[New,number]){

                    if(Tracks[New:explode("|")[2,string],table]["delete",number] == 0){
                    
                        Heap:pushString(Next)
                        
                    }
                    
                    Seen[New,number] = 1
                    
                }
                
            }
                
            Heap:remove(1)
            Xplor = Heap[1,string]
            
        }
        
        RouteKey[Start+" "+End,array] = array("0|"+End+"|0")
        
        return array("0|"+End+"|0")
        
    }    
    
    function printM(Print:string){ #Fancy print
        
        local P = Print:explode("||")
        
        P[1,string] = "OPS: "+P[1,string]
        
        for(X = 1,P:count()){
            #vec(60,70,150)*1.8
            printColor(vec(30,100,200),P[X,string])
            
        }
        
    }
    
    #roll for a random number using my roller arrays
    function string rollW(D:array,Not:string){
        
        #BUG: Crashes if it can't find a suitable 2nd destination for routing!
        
        #local GlobUse = minquota()
        
        #example: Dat = (3, 1, data1, 3, data2)
        #roll 2
        #is 3 higher or equal to 2? No.
        #is 3 higher or equal to 3? Yes. 
        
        local Dat = D:clone()
        
        local Bad = Tracks[Not,table]["name",string]
        local Fine = (Not == "")
        
        while(Dat:count()){
        
            local Needle = random(0,Dat[1,number])
            
            for(Y = 1,(Dat:count()-1)/2){
            
                if(Dat[(Y*2),number] >= Needle){
                    
                    if(Fine || (Tracks[Dat[(Y*2)+1,string],table]["name",string] != Bad)){
                        
                        return Dat[(Y*2)+1,string]
                        
                    }else{
                        
                        Dat:remove(Y*2+1)
                        Dat:remove(Y*2)
                        
                    }
                    
                }
                
                
            }
            
        }
        
        return ""
        
    }
    
    #text for world markers
    function entity textworld(Str:string,Pos:vector,Ang){  
        
        Display = Tracks[Str,table]["name",string]
        Vec = Tracks[Str,table]["color",vector]
        
        local Bloc = Display:upper():explode("|")
        
        local Mesh = p2mCreate(1,Pos,ang(0,Ang,0),16,vec(1))
        #I would totally use MeshScale, but for some reason it's broken on some servers? wat
        
        Mesh:p2mSetMaterial("debug/debugdrawflat")
        Mesh:p2mSetColor(Vec*1.1)
        
        #local Hypotenuse = ((Bloc:count()-1)*14)+10
        local Centr = vec(0)

        for(Y = 1, Bloc:count()){ #For each layer of the text
            
            local Text = Bloc[Y,string]:explode("")
            local Back = -Text:count()*6-24

            #For each text model, set the bodygroup and create 2 copies: one on each side if the text is not flat.
            
            for(X = 1,ceil(Text:count()/4)){    
                
                Bod = 0
                
                for(Z = 1, 4){
                    
                    local Byte = toByte(Text[(X*4)+Z-4,string])-65
                    
                    if(Byte < 0 | Byte >= 26){Byte = 26}
                    
                    Bod = Bod + Byte*(27^(Z-1))
                    
                }
                
                Mesh:p2mPushModel(1,"models/magtrains/reportingmark.mdl",array(1),
                Centr+4*vec(((Y-1)*14)+10,Back+(X*48),0):rotateAroundAxis(vec(0,1,0),90),# + Position,
                ang(0,0,0):rotateAroundAxis(vec(0,1,0),90),
                vec(4),0,0,Bod)
                
            }
            
        }
        
        Mesh:p2mBuild()
        
        return Mesh
        
    }
    
    function send(T:table){
        
        SignalStorage:pushTable(T)
        timer("send",1000)
        
    }
    
    function flash(E:entity,V:vector){
        
        holoCreate(HID,E:pos(),vec(1.03),E:angles(),V,E:model())
        holoMaterial(HID, "debug/debugdrawflat")
        holoAlpha(HID,100)
        holoParent(HID,E)
        HID++
        
    }
    
    function array verify(T:array){
        
        if(!T:count()){
            
            return array()
            
        }
        
        return T
        
    }
    
    function markcar(E:entity,Route:array,RteStep,NeedsHolding){

        local JobTable = Segments[Route[RteStep,string]:explode("|")[1,string],table]
        
        local CurrentLocTable = Tracks[Route[RteStep,string]:explode("|")[2,string],table]
        local FinalLocTable = Tracks[Route[Route:count(),string]:explode("|")[2,string],table]
        
        local PastLoc = Tracks[Route[RteStep-1,string]:explode("|")[2,string],table]

        
        if(NeedsHolding & PastLoc["zonemin",vector]:distance(PastLoc["zonemax",vector]) > 0){
            
            MainEntityList[E:id():toString(),table]["hold",number] = 1
            
        }
        
        if(MainEntityList[E:id():toString(),table]["hold",number] != 0){
            
            E:setCarTag("Waiting on Cars")
            E:setCarTagColor(vec(225))
            
        }else{
        
            #TODO: RE-ENABLE THIS WITH GENERIC BLOCK INDICATORS
            
            local FD = "" #"\n Pre-sort with: "+Segments[Route[RteStep,string]:explode("|")[1,string],table]["job",string] #Despite being good information, this line so confused operators that may delays and misnomers occured so I elected to remove it
            
            #TODO: MAKE TRAIN SYSTEM AFFECT THIS
            
            if(Segments[Route[RteStep+1,string]:explode("|")[1,string],table]["job",string] == JobTable["job",string]){
                
                FD = "\n Final Destination: "+FinalLocTable["name",string]:replace("|\n","\n"):replace("|"," ")
    
            }
            
            local Vec = JobTable["color",vector]
            
            if(FinalLocTable["name",string] == CurrentLocTable["name",string]){
                
                FD = ""
                
                local Comp = Route[RteStep,string]:explode("|")[3,string]
                
                if(Comp == "final" | Comp == "local"){
                    Vec = CurrentLocTable["color",vector]
                }
                
            }
            
            if(MainEntityList[E:id():toString(),table]["timer end",number] != 0){
                
                Vec = vec(220)
                
            }
            
            if(JobTable["desc",string] != ""){
                
                DSC = "\n"+JobTable["desc",string]
                
            }
    
            E:setCarTag("Next Destination: "+CurrentLocTable["name",string]:replace("|\n","\n"):replace("|"," ") + "\n Via: "+JobTable["job",string]+" "+JobTable["name",string]+DSC+FD)
            E:setCarTagColor(Vec)
            
        }
        
    }
    
    function number checksum(S1:string,S2:string,J:string){
        
        #uses an internal table to determine if 2 locations have already been linked by that job to prevent duplicates
        
        
    }
    
    #Reclassifies cars according to standard rules.
    function reclassifyCar(CarIDString:string){
        
        local CarData = MainEntityList[CarIDString,table]
        
        local Type = CarData["type",string]
        local Route = CarData["route",array]
        local RteStep = CarData["step",number]
        local CurrentLoc = Route[RteStep,string]:explode("|")[2,string]
    
        if(RteStep < Route:count()){ #If there's still places left to travel
            
            printM("\""+Type+"\" routed at "+CurrentLoc)
            CarData["step",number] = RteStep + 1
            
            markcar(entity(CarIDString:toNumber()),Route,RteStep+1,1)
            
        }else{
            
            if(Tracks[CurrentLoc,table]["delete",number] != 0){
                
                for(Y = 1,CarData["ents",array]:count()){
                    
                    entity(CarData["ents",array][Y,number]):propDelete()
                    
                }
                
                MainEntityList:remove(CarIDString)
                
            }else{
                
                local GoTo = rollW(Router[Type,array],CurrentLoc)
                            
                local NewRte = route(CurrentLoc,GoTo)

                MainEntityList[CarIDString,table] = table("type" = Type,"route" = NewRte,"ents" = CarData["ents",array],"step" = 2)
                
                markcar(entity(CarIDString:toNumber()),NewRte,2,1)
                
                send(table("name" = "renew","ent" = CarIDString))
                
            }
            
        }
        
    }
    
    ### Precalculated stuff
    
    #allows it to communicate with the carspawner with datasignals
    dsJoinGroup("operations")
    
    #starting the repeating timer for checking if cars are within triggers
    timer("scan cars",3000)
    timer("scan hold",10000)
        
    CommandStack = table()
    CommandStack:pushTable(table("command" = "first","stage" = "routebase"))
    
    timer("CommandStack",1000)
    
    #timer for starting timer check system
    timer("check timers",1000)
    timer("check deleted",2*60*1000)
    
    K = Segments:keys()
    
    for(X = 1,K:count()){
        
        local J = K[X,string]
        local Points = Segments[J,table]["routing",table]
        
        #[
        #Within system - means trains can pick up and move cars to other industries within the pool for some other train to pick up
        for(Y = 1,Points:count()){
            
            local D2 = Points[Y,array]
            
            for(Z = 1,D2:count()){
                
                for(XX = Z+1,D2:count()){
                
                    local L1 = D2[Z,string]
                    local L2 = D2[XX,string]
                    
                    Routes[L1,array] = verify(Routes[L1,array])
                    Routes[L1,array]:pushString(J+"|"+L2+"|within")
                    
                    Routes[L2,array] = verify(Routes[L2,array])
                    Routes[L2,array]:pushString(J+"|"+L1+"|within")
                    
                }
                
            }
            
        }]#
        
        for(Y = 1,Points:count()-1){
            
            for(XY = 1,Points[Y,array]:count()){
            
                local Loc = Points[Y,array][XY,string]
                
                if(Routes[Loc,array]:count() == 0){
                    Routes[Loc,array] = array()
                }
                
                for(Z = Y,Points:count()-1){
                    
                    local P2 = Points[Z+1,array]
                    
                    for(XX = 1,P2:count()){
                    
                        if(Loc != P2[XX,string]){# & !checksum(Loc,P2[XX,string])){
                            
                             Routes[Loc,array]:pushString(J+"|"+P2[XX,string]+"|road")
                            
                        }
                        
                    }
            
                }
                
            }
            
        }
        
    }
    
    K = Tracks:keys()
    
    for(X = 1,K:count()){
        
        local Loc = K[X,string]
        
        if(!Routes[Loc,array]:count() & Tracks[Loc,table]["area",string] == ""){
            
            Tracks[Loc,table]["badspawn",number] = 1
            
        }
        
    }

    LocsToMark = WorldMarks:keys()
    
    runOnChat(1)

}

if(dupefinished()){reset()}

if(dsClk("markthis")){ ##MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER##
    
    local CarspawnerDataRecieved = dsGetTable()
    
    local FrameID = CarspawnerDataRecieved[1,array][1,number]
    
    MainEntityList[FrameID:toString(),table] = MainEntityList[CarspawnerDataRecieved[2,string],table]:clone() 
    MainEntityList[FrameID:toString(),table]["ents",array] = CarspawnerDataRecieved[1,array]
    MainEntityList[FrameID:toString(),table]["starttime",number] = systime()
    
    #MainEntityList:remove(CarspawnerDataRecieved[2,string]) #remove placeholder ID
    
    if(!CarsCreatedByCommand[MainEntityList[FrameID:toString(),table]["uniquecommandid",string],array]:count()){CarsCreatedByCommand[MainEntityList[FrameID:toString(),table]["uniquecommandid",string],array] = array()}
    CarsCreatedByCommand[MainEntityList[FrameID:toString(),table]["uniquecommandid",string],array]:pushNumber(FrameID)
    
    local Route = MainEntityList[FrameID:toString(),table]["route",array]
    #[
    if(Tracks[Route[2,string]:explode("|")[2,string],table]["zonemin",vector]:distance(Tracks[Route[2,string]:explode("|")[2,string],table]["zonemax",vector])){ 
        MainEntityList[FrameID:toString(),table]["hold",number] = 1
    }]#

    markcar(entity(FrameID),Route,2,1)    

    send(table("name" = "spawn","ent" = FrameID:toString()))

}elseif(dsClk("donewith")){
    
    local CarspawnerDataRecieved = dsGetString()
    
    local UniqueIDBack = CarspawnerDataRecieved:toNumber()
    
    for(Y = clamp(UniqueIDBack-5,1,inf()),UniqueIDBack){
        
        local CardsToRemove = CardsCreatedByCommand[Y:toString(),array]
    
        for(X = 1,CardsToRemove:count()){

            MainEntityList:remove(CardsToRemove[X,string])
            
        }
        
    }
    
        
    local CarsToEnable = CarsCreatedByCommand[CarspawnerDataRecieved,array]

    for(X = 1,CarsToEnable:count()){

        MainEntityList[CarsToEnable[X,number]:toString(),table]:remove("NotTracking")
        
    }
       
}

if(chatClk(owner())){ #Text parser
    
    local LSC = owner():lastSaid():lower():trim() 
    local LSCE = LSC:explode(" ")
    
    if(LSCE[1,string] == ".data"){
        
        printTable(MainEntityList[owner():aimEntity():id():toString(),table])         
        
        hideChat(1)
        
    }elseif(LSCE[1,string] == ".train"){
        
        CarspawnerCommandStack = table()
        TT = 1
        
        local Count = LSCE[2,string]:toNumber()
        local Loc = LSCE[3,string]
        
        if(Loc == "all"){ #spawn trains at industries
            
            XALL = 1
            R2 = table()
            
            UniqueCommandID++
            CommandStack:pushTable(table("command" = "allind","count" = Count,"stage" = "one","unique" = UniqueCommandID:toString()))
            
            
        }else{ #spawn trains normally
                
            local Tl = Tracks[Loc,table]
            
            if(Tl["spawnpos",vector] != vec(0) & !Tl["badspawn",number]){
                
                Adder = table()
            
                CarspawnerCommandStack[(TT):toString(),array] = array("summon",Tl["spawnpos",vector]+vec(0,0,10),Tl["spawnang",number])
                TT++
                
                UniqueCommandID++
                CommandStack:pushTable(table("command" = "train-std-1","count" = Count,"loc" = Loc,"within" = "","unique" = UniqueCommandID:toString()))
                
            }else{
            
                printM("Invalid spawning location \""+Loc+"\"")
                
            }
            
        }
        
        hideChat(1)
        
    }elseif(LSCE[1,string] == ".bonk"){
        
        local PlayerAimEntity = owner():aimEntity()
        
        hideChat(1)
        
        local CarData = MainEntityList[PlayerAimEntity:id():toString(),table]
        
        if(PlayerAimEntity:isValid() & CarData:count()){
            
            printM("Kicked the car to the next stage")
            
            CarData["hold",number] = 0
            
            startEntityIDTimer(PlayerAimEntity:id():toString(),0)
            
        }
        
    }elseif(LSCE[1,string] == ".reworldmark"){
        
        hideChat(1)
        printM("Removed "+WorldMarkEnts:count()+" markers and remade them.")
        
        while(WorldMarkEnts:count()){
            
            WorldMarkEnts[1,entity]:propDelete()
            WorldMarkEnts:remove(1)
            
        }
        
        LocsToMark = WorldMarks:keys()
        
    }elseif(LSCE[1,string] == ".era"){
        
        Era = LSCE[2,string]
        printM("Set era to "+Era)
        hideChat(1)
        
    }elseif(LSCE[1,string] == ".inbound"){
        
        stoptimer("spawn inbound")
        timer("spawn inbound",1000)
        hideChat(1)
        
    }elseif(LSCE[1,string] == ".target"){
        
        if(LSCE[2,string]:toNumber() <= 0){
            
            printM("Target Carcount is currently "+TargetCarcount)
            
        }else{
        
            TargetCarcount = LSCE[2,string]:toNumber()
            printM("Target Carcount set to "+TargetCarcount)
            
        }
        
        hideChat(1)
        
    }elseif(LSCE[1,string] == ".ohboyherewego" & owner():aimEntity() == entity()){
        
        print("We're really doing this!")
        
        hideChat(1)
        
        MainEntityList = Reload:clone()
        local Keys = MainEntityList:keys()
        Inc = IncRel
        SortedTimers = array()
        
        for(X = 1,Keys:count()){
            
            if(MainEntityList[Keys[X,string],table]["timer end",number] != 0){
                
                startEntityIDTimer(Keys[X,string],1)
                
            }
            
        }
        
        #this needs a queue: gets dangerously low

    }
    
}

if(chatClk()){
    
    if(lastSaid() == ".clarify"){
        
        local PlayerAimEntity = lastSpoke():aimEntity()
        local T2 = MainEntityList[PlayerAimEntity:id():toString(),table]
        
        if(PlayerAimEntity:isValid() & T2:count()){
            
            printM(lastSpoke():name()+" reapplied "+PlayerAimEntity:id()+"'s car marker.")
            markcar(PlayerAimEntity,T2["route",array],T2["step",number],0)
            
        }
        
    }
    
}

if(clk("spawn inbound")){
    
    timer("spawn inbound",15*60*1000)
    
    if(TargetCarcount > CurrentCarcount){
        
        printM("Queued inbound train.")

        CarspawnerCommandStack = table()
        TT = 1
        
        local Count = randint(9,14)
        local Loc = select(randint(1,2),"goldstone","daviscity")
            
        local Tl = Tracks[Loc,table]
        
        findInBox(Tl["boxlo",vector],Tl["boxhi",vector])
        findClipToClass("prop_physics")
        
        local Find = findToArray()
        
        if(!Find:count()){
            
            Adder = table()
        
            CarspawnerCommandStack[(TT):toString(),array] = array("summon",Tl["spawnpos",vector]+vec(0,0,10),Tl["spawnang",number])
            TT++
            
            UniqueCommandID++
            CommandStack:pushTable(table("command" = "train-std-1","count" = Count,"loc" = Loc,"within" = "","unique" = UniqueCommandID:toString()))
            
        }
        
    }
    
}


if(clk("scan cars")){ 
    
    timer("scan cars",5000)
    
    if(!CarsToScan:count()){
        CarsToScan = MainEntityList:keys()
        CurrentCarcount = StoredCarcount
        StoredCarcount = 0
    }
    
}elseif(clk("check timers")){
    
    timer("check timers",2000)
    
    while(SortedTimers[2,number] != 0 & SortedTimers[2,number] < systime() & safe()){
        
        local CarIDString = SortedTimers[1,string] #Name of Timer
        local CarTable = MainEntityList[CarIDString,table]
        
        MainEntityList[CarIDString,table]["timer end",number] = 0
        
        if(CarTable:count() > 0){ #if car data is Valid:
            
            local CurrentLoc = CarTable["route",array][CarTable["step",number],string]:explode("|")[2,string]
            
            reclassifyCar(CarIDString)
            
            #[
            if(Tracks[CurrentLoc,table]["zonemin",vector]:distance(Tracks[CurrentLoc,table]["zonemax",vector])){
                
                CarTable["hold",number] = 1
                
            }]#
            
        }
        
        SortedTimers:remove(1)
        SortedTimers:remove(1)
        
        
        
    }
    
}elseif(clk("scan hold")){
    
    if(!CarsToHold:count() & HoldState == ""){
        CarsToHold = MainEntityList:keys()
        JobsActive = JobsStored:clone()
        JobsStored = table()
        HoldState = "start"
        CarsAvailable = table()
        CarsReady = table()
        
    }
    
    timer("scan hold",10000)
    
}elseif(clk("check deleted")){
    
    CheckDeletions = MainEntityList:keys()
    
    timer("check deleted",0.1*60*1000)
    
}

if(ToSendOut != table() & minquota() > 3000){
    
    dsSend("populate","operations",ToSendOut)
    ToSendOut = table()
    
}

if(clk("CommandStack")){
    
    timer("CommandStack",250)

    if(CommandStack[1,table]["command",string] == "train-std-1" & safe()){
        
        while(CommandStack[1,table]["count",number] & safe()){
                     
            local Type = rollW(Stock,"")
            local GoTo = rollW(Router[Type,array],CommandStack[1,table]["loc",string])
            
            local Mask = Tracks[CommandStack[1,table]["loc",string],table]["excl",string]
            
            while((Mask == Tracks[GoTo,table]["excl",string] & Mask != "") | (CommandStack[1,table]["loc",string] == GoTo)){
                    
                Type = rollW(Stock,"")
                GoTo = rollW(Router[Type,array],CommandStack[1,table]["loc",string])
                    
            }
            
            local Route = route(CommandStack[1,table]["loc",string],GoTo)                 
                
            #mechanism that generates an "Index" for each track, allowing sorting  
            local Index = CommandStack[1,table]["loc",string]
            
            for(X = 1,Route:count()){
                
                Index = Index + Route[X,string]
                
            }
            
            
            for(Y = 1,Adder:count()+1){
                
                if(Index > Adder[Y,array][4,string]){
                
                    local TempID = "ph"+PlaceholderID
                    local UniqueID = CommandStack[1,table]["unique",string]
                    
                    MainEntityList[TempID,table] = table("type" = Type,"route" = Route,"NotTracking" = 1,"uniquecommandid" = UniqueID,"step" = 2)
                    
                    
                    if(!CardsCreatedByCommand[UniqueID,array]:count()){CardsCreatedByCommand[UniqueID,array] = array(TempID)}else{CardsCreatedByCommand[UniqueID,array]:pushString(TempID)}
                    PlaceholderID++
                    
                    Adder:insertArray(Y,array(".sp 0 "+Era+" "+Type,vec(distrand(3,3),0,0),TempID,Index))
                    
                    
                    break
                    
                }
                 
            }
            
            CommandStack[1,table]["count",number] = CommandStack[1,table]["count",number] - 1
            
        }
        
        if(!CommandStack[1,table]["count",number]){
            
            for(X = 1,Adder:count()){
                
                Adder[X,array]:remove(4)
                
                CarspawnerCommandStack[(TT):toString(),array] = Adder[X,array]
                TT++
                
            }
            
            CarspawnerCommandStack[(TT):toString(),array] = array("summon",vec(0),0)
            TT++
            CarspawnerCommandStack[(TT):toString(),string] = CommandStack[1,table]["unique",string]
            
            send(table("name" = "train","unique" = CommandStack[1,table]["unique",string]))
            
            ToSendOut = CarspawnerCommandStack
        
            printM("spawned train length "+Adder:count()+" at "+CommandStack[1,table]["loc",string])
            
            CommandStack:remove(1)
            
        }
        
    }elseif(CommandStack[1,table]["command",string] == "first" & safe()){
            
        #pull out types from Tracks and use them to lay the foundation for the router
        
        if(CommandStack[1,table]["stage",string] == "routebase" & safe()){
        
            local K = Tracks:keys()
            
            for(X = 1, K:count()){
                
                local Dat = Tracks[K[X,string],table]["work",array]
                
                for(Y = 1,Dat:count()){
                    
                    local Dat2 = Dat[Y,string]
                    
                    if(Dat2 != ""){
        
                        Router[Dat2,array] = array(0)
                        Router[swap(Dat2),array] = array(0)
                        
                    }
                    
                }
                
                if(Tracks[K[X,string],table]["traffic",number] > 0){ #this is intentional, this way -1 offmap's don't get more work added
                    
                    Interchanges = Interchanges:add(array(K[X,string],Tracks[K[X,string],table]["traffic",number]))
                    
                }
                
            }
            
            Ktr = Tracks:keys()
            
            #vars for test train spawn (see below)
            CarspawnerCommandStack = table()
            TT = 1
            
            #essential variable
            Default = table()
            
            CommandStack[1,table]["stage",string] = "tracks"
            Xt = 1
            
        }
        
        if(CommandStack[1,table]["stage",string] == "tracks" & safe()){
            
            while(Xt <= Ktr:count() & holoCanCreate() & safe()){
                
                Index = Ktr[Xt,string]
                local Tl = Tracks[Index,table]
                
                local P = Tl["boxhi",vector]
                local N = Tl["boxlo",vector]
                local R = Tl["boxrot",number]
                
                local C = ((P+N)*0.5)
            
                local C2 = C:rotateAroundAxis(vec(0,0,1),R)
                
                Tl["boxhi",vector] = C2+(P-C)
                Tl["boxlo",vector] = C2-(P-C)
                
                local Sc = newabs((1/2048)*(Tl["boxlo",vector]-Tl["boxhi",vector]))
            
                #[marks the trigger zones with boxes
                holoCreate(HID,C,Sc,ang(0,0,0):rotateAroundAxis(vec(0,0,1),-R),Tl["color",vector],"models/props_metaladon/parts/boundingbox.mdl")
                holoAlpha(HID,70)
                holoMaterial(HID,"debug/debugdrawflat")
                HID++
                #]#
                
                local Rte = Tl["work",array]
                
                for(Y = 1,Rte:count()/2){
                    
                    local Q = Rte[Y*2-1,number]
                    local D = Rte[Y*2,string]
                    
                    Router[D,array]:pushNumber(Router[D,array][1,number] + Q)
                    Router[D,array]:pushString(Index)
                    Router[D,array][1,number] =  Router[D,array][1,number] + Q
                    
                    Default[D,number] =  Default[D,number] + Q
                    
                }
                
                #this code is just for the bit below this, not super nessecary
                
                Type = Rte[2,string]
                Count = Rte[1,number]
                
                if(Type != ""){
                
                    CarspawnerCommandStack[(TT*2-1):toString(),array] = array("summon",Tl["spawnpos",vector]+vec(0,0,20),Tl["spawnang",number])
                    CarspawnerCommandStack[(TT*2):toString(),array] = array(".sp 0 "+Era+" "+swap(Type),vec(Count,0,0),Index)
                    TT++
                    
                }
                
                Xt++
                
                
            }
            
            if(Xt > Ktr:count()){
                
                CommandStack[1,table]["stage",string] = "finish" 
                
                #dsSend("populate","operations",CarspawnerCommandStack) #this line sends a command to spawn 1 car of the correct type at every location to verify it works
                
            }
            
            
            
        }
        
        if(CommandStack[1,table]["stage",string] == "finish" & safe()){
        
            local KD = Default:keys()
            Stock = array(0)
            
            for(X = 1,KD:count()){
                
                local K = KD[X,string]
                
                Stock:pushNumber(Stock[1,number] + Default[K,number])
                Stock[1,number] = Stock[1,number] + Default[K,number]
                Stock:pushString(K)
                
            }
            
            local KA = Router:keys()
                
            for(X = 1,KA:count()){
                
                local Entry = KA[X,string]
                local Base = 1
                
                if(Router[Entry,array][1,number] != 0){
                    
                    Base =  Router[Entry,array][1,number]
                    
                }
                
                for(Y = 1,Interchanges:count()/2){
                    
                    local Add = Interchanges[Y*2,number] * Base
                    
                    Router[Entry,array][1,number] = Router[Entry,array][1,number] + Add
                    Router[Entry,array]:pushNumber(Router[Entry,array][1,number])
                    Router[Entry,array]:pushString(Interchanges[Y*2-1,string])
                    
                }
                
                
            }
            
            CommandStack:remove(1)
            
        }
        
    }elseif(CommandStack[1,table]["command",string] == "allind" & safe()){
        
        if(CommandStack[1,table]["stage",string] == "one" & safe()){
        
            while(XALL <= CommandStack[1,table]["count",number] & safe()){
                
                local Type = rollW(Stock,"")
                local Loc2 = rollW(Router[Type,array],"")
                
                while(Tracks[Loc2,table]["delete",number] != 0){
                    
                    Type = rollW(Stock,"")
                    Loc2 = rollW(Router[Type,array],"")
                    
                }
                
                local Type = swap(Type)
                
                local Mask = Tracks[Loc2,table]["excl",string]
                local GoTo = rollW(Router[Type,array],Loc2)
                
                while(Mask == Tracks[GoTo,table]["excl",string]){
                    
                    GoTo = rollW(Router[Type,array],Loc2)
                    
                }
                
                if(R2[Loc2,table]:count() == 0){
                    
                    R2[Loc2,table] = table()
                    
                }   
                
                local Route = route(Loc2,GoTo)
                
                local TempID = "ph"+PlaceholderID
                local UniqueID = CommandStack[1,table]["unique",string]
                
                MainEntityList[TempID,table] = table("type" = Type, "route" = Route, "NotTracking" = 1, "uniquecommandid" = UniqueID,"step" = 2)
                if(!CardsCreatedByCommand[UniqueID,array]:count()){CardsCreatedByCommand[UniqueID,array] = array(TempID)}else{CardsCreatedByCommand[UniqueID,array]:pushString(TempID)}
                PlaceholderID++
                
                R2[Loc2,table]:pushArray(array(".sp 0 "+Era+" "+Type,vec(distrand(3,3),0,0),TempID))
                
                GoTo+"|"+Loc2+"|"+Type
                
                XALL++
    
            }
            
            if(XALL > CommandStack[1,table]["count",number]){
                
                Ktr = R2:keys()
                CommandStack[1,table]["stage",string] = "two"
                XALL = 1
                
            }
            
        }
        
        if(CommandStack[1,table]["stage",string] == "two" & safe()){
        
            while(XALL <= Ktr:count() & safe()){
                
                local Tl = Tracks[Ktr[XALL,string],table]
                
                CarspawnerCommandStack[(TT):toString(),array] = array("summon",Tl["spawnpos",vector]+vec(0,0,20),Tl["spawnang",number])
                TT++
                
                local Add = R2[Ktr[XALL,string],table]
                
                for(Y = 1,Add:count()){
                    
                    CarspawnerCommandStack[(TT):toString(),array] = Add[Y,array]
                    TT++
                    
                }
                
                XALL++
                
            }
            
            if(XALL > Ktr:count()){
                
                CarspawnerCommandStack[(TT):toString(),array] = array("summon",vec(0),0)
                TT++
                CarspawnerCommandStack[(TT):toString(),string] = CommandStack[1,table]["unique",string]
                
                ToSendOut = CarspawnerCommandStack
                
                printM("spawned "+CommandStack[1,table]["count",number]+" cars at \"all industries\"")
                
                CommandStack:remove(1)
                
            }
            
        }
        
        
    }
    
    
    while(safe() & CarsToScan:count()){
        
        if(CarsToScan[1,string]:toNumber() != 0 & MainEntityList[CarsToScan[1,string],table]["NotTracking",number] != 1){
        
            local CarTable = MainEntityList[CarsToScan[1,string],table]
            
            local Route = CarTable["route",array]
            local RteStep = CarTable["step",number]
            
            StoredCarcount = StoredCarcount + 1
            
            if(CarTable["timer end",number] == 0 & CarTable["hold",number] == 0 & within(entity(CarTable["ents",array][1,number]):pos(),Route[RteStep,string]:explode("|")[2,string])){
                
                local IsGoingOffMap = Tracks[Route[RteStep,string]:explode("|")[2,string],table]["delete",number] != 0
                startEntityIDTimer(CarsToScan[1,string],1)
                send(table("name" = "reroute","ent" = CarsToScan[1,string],"where" = CarTable["route",array][RteStep,string]:explode("|")[2,string],"count" = ((Route:count()-RteStep)+1),"isoffmap" = IsGoingOffMap))
                if(IsGoingOffMap){MainEntityList[CarsToScan[1,string],table]["out",number] = 1}
                
            }
            
        }
        
        CarsToScan:remove(1)
    
    }
    
    while(safe() & CarsToHold:count() & HoldState == "start"){
        
        if(CarsToHold[1,string]:toNumber() != 0 & MainEntityList[CarsToHold[1,string],table]["NotTracking",number] != 1){
        
            local CarTable = MainEntityList[CarsToHold[1,string],table]
            local Route = CarTable["route",array]
            local CurrentJob = Route[CarTable["step",number],string]:explode("|")[1,string]
            local CurrentLoc = CarTable["route",array][CarTable["step",number]-1,string]:explode("|")[2,string]
            
            if(CarTable["timer end",number] == 0){JobsStored[CurrentJob,number] = JobsStored[CurrentJob,number] + 1}
            
            local ZoneMax = Tracks[CurrentLoc,table]["zonemax",vector]
            local ZoneMin = Tracks[CurrentLoc,table]["zonemin",vector]
            
            if(boxed(ZoneMax,ZoneMin,entity(CarTable["ents",array][1,number]):pos())){
                
                local TrainToGoOut = Segments[CurrentJob,table]["train",string]
            
                if(CarTable["hold",number]){
                    
                    local BlockMin = Segments[CurrentJob,table]["min",number]
                    local BlockMax = Segments[CurrentJob,table]["max",number]
                    local TrainMin = Trains[TrainToGoOut,table]["min",number]
                    local TrainMax = Trains[TrainToGoOut,table]["max",number]
                    
                    ToEvaluate:pushTable(table(CarsToHold[1,string],BlockMin,BlockMax,TrainMin,TrainMax,CurrentLoc,CurrentJob))
                    
                }
                
                #flash(entity(CarTable["ents",array][1,number]),vec(0,255,0))
                
                
                if(!CarsAvailable[CurrentLoc,table]:count()){
                    CarsAvailable[CurrentLoc,table] = table()
                }
                
                increment(CarsAvailable[CurrentLoc,table],CurrentJob,1)
                if(TrainToGoOut != ""){increment(CarsAvailable[CurrentLoc,table],TrainToGoOut,1)}
                
                if(!CarTable["hold",number]){
                    
                    if(!CarsReady[CurrentLoc,table]:count()){
                        CarsReady[CurrentLoc,table] = table()
                    }
                    
                    increment(CarsReady[CurrentLoc,table],CurrentJob,1)
                    if(TrainToGoOut != ""){increment(CarsReady[CurrentLoc,table],TrainToGoOut,1)}
                    
                }
                
            }elseif(CarTable["hold",number]){
                
                MainEntityList[CarsToHold[1,string],table]["hold",number] = 0
                markcar(entity(CarsToHold[1,string]:toNumber()),Route,CarTable["step",number],0)
                
            }
                
        }
        
        CarsToHold:remove(1)
        
    }
    
    if(!CarsToHold:count() & HoldState == "start"){
        
        HoldState = "blocks"
        BlockIncrX = 1
        LocationKeys = CarsAvailable:keys()
        BlocksOK = table()
        
        
    }
    
    while(HoldState == "blocks" & safe() & BlockIncrX <= CarsAvailable:count()){
        
        local CurrentLoc = LocationKeys[BlockIncrX,string]
        local Blocks = CarsAvailable[CurrentLoc,table]
        
        for(Y = 1,Blocks:count()){
            
            local CurrentJob = Blocks:keys()[Y,string]
        
            local A = (Segments[CurrentJob,table]["min",number] == 0 | CarsAvailable[CurrentLoc,table][CurrentJob,number] >= Segments[CurrentJob,table]["min",number])
            
            if(!BlocksOK[CurrentLoc,table]:count()){
                BlocksOK[CurrentLoc,table] = table()
            }
            
            local Train = Segments[CurrentJob,table]["train",string]
                
            if(Train != ""){
                
                if(!BlocksOK[CurrentLoc,table][Train,table]:count()){
                    BlocksOK[CurrentLoc,table][Train,table] = table()   
                }
                    
                if(A){increment(BlocksOK[CurrentLoc,table][Train,table],"tilmin",CarsAvailable[CurrentLoc,table][CurrentJob,number])}
                increment(BlocksOK[CurrentLoc,table][Train,table],"tilmax",CarsReady[CurrentLoc,table][CurrentJob,number])
                
                #here's why we need both. This cycle, the train needs to know 2 things: Do I have enough cars to meet the minimum, and how many cars do I have currently counting against the maximum?
                #"tilmin" adds up all the cars that could be available AND are guarenteed to have enough to leave;
                #"tilmax" adds up the currently marked cars, so when adding additional cars it knows how many the train already posesses and won't go over.
                
            }

        }
        
        BlockIncrX++
        
    }
    
    if(HoldState == "blocks" & BlockIncrX > CarsAvailable:count()){
        
        HoldState = "process"
        
        #printTable(BlocksOK["wolfram",table])
        
    }
    
    while(ToEvaluate:count() & HoldState == "process" & safe()){
        
        local CarToEval = ToEvaluate[1,table]
        
        #block minimum check (do I have enough to meet X)
        #block maximum check (will this put me over y)
        #train minimum check (do I have enough to meet X)
        #train maximum check (will this put me over y)
        #min-max check (does the number of cars in the train minus this specific block plus the minimum of this block equal more than the maximum of the train?)
        
        #need a 5th check for "do I have enough cars to satisfy the block AND train minimums for this block"
        #meant to avoid a situation where a train "sends out" a block and 2 half-blocks; the full block sees it has "enough cars" for a train, and the half-blocks haven't met their minimums yet
        
        local Train = Segments[CarToEval[7,string],table]["train",string]
        
        local BlockMin = CarToEval[2,number]
        local BlockMax = CarToEval[3,number]
        local TrainMin = CarToEval[4,number]
        local TrainMax = CarToEval[5,number]
        
        local Location = CarToEval[6,string]
        local Segment = CarToEval[7,string]
    
        local ApprovedMin = BlocksOK[Location,table][Train,table]["tilmin",number]
        local ApprovedMax = BlocksOK[Location,table][Train,table]["tilmax",number]
        
        local Ready = CarsReady[Location,table][Segment,number]
        local Available = CarsAvailable[Location,table][Segment,number]
        
        local A = (!BlockMin | Available >= BlockMin)
        local B = (!BlockMax | Ready < BlockMax)
        local C = (!TrainMin | ApprovedMin >= TrainMin)
        local D = (!TrainMax | ApprovedMax < TrainMax)
        
        local E = ((Train == "" | !TrainMax | !BlockMin) | (ApprovedMax - Ready + BlockMin) < TrainMax)
        
        if(A+B+C+D+E == 5){
            
            increment(CarsReady[Location,table],Segment,1)
            increment(BlocksOK[Location,table][Train,table],"tilmax",1)
            
            printM("Unheld Car "+CarToEval[1,string]+", job "+Segment)
            
            local CarTable = MainEntityList[CarToEval[1,string],table]
            MainEntityList[CarToEval[1,string],table]["hold",number] = 0
            markcar(entity(CarToEval[1,string]:toNumber()),CarTable["route",array],CarTable["step",number],0)
            
        }else{#[
            if(Segment != "rwd1"){
                
                print(CarToEval[1,string]+" "+A+" "+B+" "+C+" "+D+" "+E)
                #print(CarToEval[1,string]+" "+ApprovedMin+" "+TrainMin)
                
            }]#
        }
        
        ToEvaluate:remove(1)
        
        
    }
    
    TEC = ToEvaluate:count()
    
    while(CheckDeletions:count() & safe()){
        
        local CarTable = MainEntityList[CheckDeletions[1,string],table]
        local CarEnts = CarTable["ents",array]
        
        if(CheckDeletions[1,string]:toNumber() != 0){
        
            for(X = 1,CarEnts:count()){
            
                if(!entity(CarEnts[X,number]):isValidPhysics()){
        
                    for(Y = 1,CarEnts:count()){
                            
                        entity(CarEnts[Y,number]):propDelete()
                        
                    }
                    
                    if(CarTable["out",number] == 0){
                    
                        send(table("name" = "deleted","ent" = CarEnts[1,number]:toString()))
                        
                    }
                        
                    MainEntityList:remove(CheckDeletions[1,string])
                        
                    break
                    
                }
                
            }
            
        }
        
        CheckDeletions:remove(1)
        
    }
    
    if(HoldState == "process" & TEC == 0){
        
        HoldState = ""
        
    }
    
    while(LocsToMark:count() & safe()){
        
        local A = WorldMarks[LocsToMark[1,number],array]
        WorldMarkEnts:pushEntity(textworld(A[1,string],A[2,vector],A[3,number]))
        LocsToMark:remove(1)
        
    }
    
}

if(clk("send")){
    
    if(SignalStorage:count() & Response == Inc){
        
        Signal = SignalStorage[1,table]:clone()
        SignalStorage:remove(1)
        Inc = Response + 1
        
    }
    
    if(SignalStorage:count()){
    
        timer("send",50)
        
    }
    
}





    
    
