@name Operations v1.441
@persist HID TargetCarcount PlaceholderID UniqueCommandID TT Xt XALL CurrentCarcount StoredCarcount BlockIncrX TEC TypeIncr IncrX IncrY OverallSpawned IndTurn

@persist [MainEntityList Tracks CarsCreatedByCommand AllDestinationsBTR LocalDestinationsBTR LocalSourcesBTR AllSourcesBTR ToSendOut WorldMarks Adder CommandStack CarspawnerCommandStack SpawnCommandsByLocation]:table
@persist [Segments RouteKey Routes JobsActive JobsStored CarsAvailable CarsReady ToEvaluate Trains BlocksOK CardsCreatedByCommand TrafficRatiobyType FromTrafficRatiobyType SpawningGroups SavedSpawnData]:table

@persist [Era HoldState Pairs ]:string
@persist [LocsToMark ShareAllRoller InboundTracksRoller OutboundTracksRoller TracksKeys WorldMarkEnts SortedTimers CarsToScan CarsToHold LocationKeys CheckDeletions CarTypesList CarsRoller TimersToRecheck TracksToProcess ToSpawnData]:array

@outputs CurrentCarcount CommandStack:table XALL JobsActive:table SortedTimers:array HoldState:string CarsToHold:array CarsToScan:array Tracks:table TEC TypeIncr IncrX IncrY # [Sector1 Sector2 Sector3 Sector4 Sector5 Sector6 Sector7 Sector8 Sector9]:string

@inputs Response Reload:table IncRel
@persist Inc Signal:table SignalStorage:table
@outputs Inc Signal:table SignalStorage:table
@outputs MainEntityList:table TimersToRecheck:array
@trigger none

@model models/props_lab/servers.mdl

if(first() | dupefinished()){
    
    #v1.44 - Removing technical debt related to the Area system + lading work
    #v1.441 - fixing a ton of bugs and oversights related to the new system
    #v1.442 - northward implementation + data cleanup code
    
    
    ####SETTINGS#############################################################

    Era = "1980s" #Set the Era string here. Use the same names as the Carspawner would.
    
    #Configuration file for the map
    
    ##include "opsconfig/ssg_phx_jobs"
    ##include "opsconfig/ssg_rsg_jobs"
    ##include "opsconfig/lober_jobs"
    ##include "opsconfig/ssgrsg_test"
    #include "opsconfig/northward_jobs"
    
    ####END_SETTINGS#########################################################
    
    
    #JOB CLEANUP CODE - can't be moved else E2 will whine
    local KJ = Segments:keys()
    local TestColors = array()
    
    for(X = 1,KJ:count()){
        
        J = KJ[X,string]
        
        if(Segments[J,table]["color",vector] != vec(0)){
            
            Segments[J,table]["color",vector] = clamp(Segments[J,table]["color",vector],vec(0),vec(255))
            TestColors:pushVector(Segments[J,table]["color",vector])
            TestColors:pushString(Segments[J,table]["name",string])
            
        }
        
    }
    
    #variable delarations to get the server to shut up
    Router = table()
    SignalStorage = table()
    ToSendOut = table()
    ShareAllRoller = array(0)
    InboundTracksRoller = array(0)
    OutboundTracksRoller = array(0)
    HID = 0
    
    ### Functions
    
    function vector newabs(V:vector){
        
        return vec(abs(V:x()),abs(V:y()),abs(V:z()))
        
    }
    
    function number boxed(V1:vector,V2:vector,V3:vector){
        
        #If V3 is within max V1 and min V2, return 1.
        
        if(V1:distance(V2) > 0){
        
            return ((V1:x() >= V3:x()) + (V1:y() >= V3:y()) + (V1:z() >= V3:z()) + (V2:x() <= V3:x()) + (V2:y() <= V3:y()) + (V2:z() <= V3:z()) == 6)
            
        }
        
        return 0
        
    }

    function number within(V:vector,S:string){
        
        #S is the location code for the current target location
        
        local CX = Tracks[S,table]["boxhi",vector]
        local CN = Tracks[S,table]["boxlo",vector]
        
        local R = Tracks[S,table]["boxrot",number]
        
        
        local V2 = V:rotateAroundAxis(vec(0,0,1),R)
        
        return boxed(CX,CN,V2)
        
    }
    
    function number distrand(N,D){
        
        return 1
        
        return floor(N-random(0,N^D)^(1/D))+1
        
    }
    
    function increment(T:table,S:string,N){
        
        T[S,number] = T[S,number]+N
        
    }
    
    function string toString(R:array){
        
        #returns a string version of an array made of strings
        
        if(!R:count()){
            
            return ""
            
        }else{
        
            local S = R[1,string]
            
            for(X = 2,R:count()){
                
                S = S + ", "+R[X,string]
                
            }
            
            return S
            
        }
        
    }
    
    function startEntityIDTimer(S:string,N){
        
        entity(S:toNumber()):setCarTagColor(vec(220))
        
        local TimerEnd = 0
        
        if(N != 0){
    
            #Relative to the System Time, in seconds
            TimerEnd = systime() + max(Tracks[MainEntityList[S,table]["route",array][MainEntityList[S,table]["step",number],string]:explode("|")[2,string],table]["time",number],0.01)*60 #original time is in minutes
            
        }else{
            
            TimerEnd = systime()
            
        }
        
        MainEntityList[S,table]["timer end",number] = TimerEnd
        
        local Index = 1
        
        while(SortedTimers[Index*2,number] < TimerEnd & SortedTimers[Index*2,number]){
            
            Index++
            
        }
        
        SortedTimers:insertString(Index*2-1,S)
        SortedTimers:insertNumber(Index*2,TimerEnd)
        
        
    }
    
    function number safe(){ #Function that determines if the current iteration is out of processing time
        
        return minquota() > 1000
 
    }
    
    RouteKey = table()
    Routes = table()
    
    
    function array route(Start:string,End:string){
        
        if(RouteKey[Start+" "+End,array]:count()){
            
            return RouteKey[Start+" "+End,array]
            
        }
        
        if(Tracks[Start,table]["part of",string] != ""){
            
            TrueStart = Tracks[Start,table]["part of",string]
            
        }else{
            
            TrueStart = Start
            
        }
        
        if(Tracks[End,table]["part of",string] != ""){
            
            TrueEnd = Tracks[End,table]["part of",string]
            
        }else{
            
            TrueEnd = End
            
        }
        
        if(TrueStart == TrueEnd){
            
            return array("0|"+TrueStart+"|0","loc|"+End+"|local")
            
        }
        
        
        local Seen = table()
            
        Heap = array(TrueStart)
        
        local Xplor = "0|"+TrueStart+"|0"
        
        while(Heap:count()){
            
            local A = Xplor:explode("?")
            local B = A[A:count(),string]
            local C = B:explode("|")[2,string]   
            local Add = Routes[C,array]
            
            for(X = 1,Add:count()){
                
                local New = Add[X,string]
                
                local Next = Xplor+"?"+New
                
                if(New:explode("|")[2,string] == TrueEnd | New:explode("|")[2,string] == End){
                    
                    N = Next:explode("?")
                    RouteKey[TrueStart+" "+TrueEnd,array] = N
                    
                    if(New:explode("|")[2,string] != End){
                        local Final = N[N:count(),string]:explode("|")
            
                        Final[3,string] = "final"
                        Final[2,string] = End
                        N:pushString(Final[1,string]+"|"+Final[2,string]+"|"+Final[3,string])
                        
                    }
                    
                    return N
                    
                }
                
                if(!Seen[New,number]){

                    if(Tracks[New:explode("|")[2,string],table]["delete",number] == 0 & Tracks[New:explode("|")[2,string],table]["not a destination",number] == 0){
                    
                        Heap:pushString(Next)
                        
                    }
                    
                    Seen[New,number] = 1
                    
                }
                
            }
                
            Heap:remove(1)
            Xplor = Heap[1,string]
            
        }
        
        RouteKey[Start+" "+End,array] = array("0|"+End+"|0")
        
        return array("0|"+End+"|0")
        
    }    
    
    function printM(Print:string){ #Fancy print
        
        local P = Print:explode("||")
        
        P[1,string] = "OPS: "+P[1,string]
        
        for(X = 1,P:count()){
            #vec(60,70,150)*1.8
            printColor(vec(30,100,200),P[X,string])
            
        }
        
    }
    
    #[
    #roll for a random number using my roller arrays
    function string rollW(D:array,Not:string){
        
        #BUG: Crashes if it can't find a suitable 2nd destination for routing!
        
        #local GlobUse = minquota()
        
        #example: Dat = (3, 1, data1, 3, data2)
        #roll 2
        #is 3 higher or equal to 2? No.
        #is 3 higher or equal to 3? Yes. 
        
        if(D:count() == 3){
            
            return D[3,string]
            
        }
        
        local Dat = D:clone()
        
        local Bad = Tracks[Not,table]["name",string]
        local Fine = (Not == "")
        
        while(Dat:count()){
        
            local Needle = random(0,Dat[1,number])
            
            for(Y = 1,(Dat:count()-1)/2){
            
                if(Dat[(Y*2),number] >= Needle){
                    
                    if(Fine || (Tracks[Dat[(Y*2)+1,string],table]["name",string] != Bad)){
                        
                        return Dat[(Y*2)+1,string]
                        
                    }else{
                        
                        Dat:remove(Y*2+1)
                        Dat:remove(Y*2)
                        
                    }
                    
                }
                
                
            }
            
        }
        
        return ""
        
    }]#
    
    #rebuilt quadratic roller that should be a lot faster
    function string rollW(D:array,Not:string){
        
        if(D:count() == 3){
            
            return D[3,string]
            
        }
        
        #example: Dat = (5, 1, data1, 3, data2, 5, data3)
        #goal = 2
        
        #count is 7 
        #CurrentPos should be 2
        
        #expected outcome = data2
        
        local Dat = D:clone()
        
        local Bad = Tracks[Not,table]["name",string]
        local Fine = (Not == "")
        
        while(Dat:count()){
        
            local Goal = random(0,Dat[1,number])
            local CurrentPos = round(Dat:count()/4)
            local Step = max(Dat:count()/8,1)
            local Direction = 2
            
            while(Direction != 0){
                
                Direction = 0
    
                if(Dat[(CurrentPos-1)*2,number] > Goal){
                    
                    Direction = -1
    
                }elseif(Dat[CurrentPos*2,number] < Goal){
                    
                    Direction = 1
                    
                }
                
                CurrentPos = round(CurrentPos + Step*Direction)
                
                Step = max(Step/2,1)
                
                
            }
    
                    
            if(Fine || (Tracks[Dat[CurrentPos*2+1,string],table]["name",string] != Bad)){
                
                return Dat[CurrentPos*2+1,string]
                
            }else{
                
                Dat:remove(CurrentPos*2+1)
                Dat:remove(CurrentPos*2)
                
            }
            
        }
        
        return ""
        
    }
    
    #text for world markers
    function entity textworld(Str:string,Pos:vector,Ang){  
        
        Display = Tracks[Str,table]["name",string]
        Vec = Tracks[Str,table]["color",vector]
        
        local Bloc = Display:upper():explode("|")
        
        local Mesh = p2mCreate(1,Pos,ang(0,Ang,0),16,vec(1))
        #I would totally use MeshScale, but for some reason it's broken on some servers? wat
        
        Mesh:p2mSetMaterial("debug/debugdrawflat")
        Mesh:p2mSetColor(Vec*1.1)
        
        #local Hypotenuse = ((Bloc:count()-1)*14)+10
        local Centr = vec(0)

        for(Y = 1, Bloc:count()){ #For each layer of the text
            
            local Text = Bloc[Y,string]:explode("")
            local Back = -Text:count()*6-24

            #For each text model, set the bodygroup and create 2 copies: one on each side if the text is not flat.
            
            for(X = 1,ceil(Text:count()/4)){    
                
                Bod = 0
                
                for(Z = 1, 4){
                    
                    local Byte = toByte(Text[(X*4)+Z-4,string])-65
                    
                    if(Byte < 0 | Byte >= 26){Byte = 26}
                    
                    Bod = Bod + Byte*(27^(Z-1))
                    
                }
                
                Mesh:p2mPushModel(1,"models/magtrains/reportingmark.mdl",array(1),
                Centr+4*vec(((Y-1)*14)+10,Back+(X*48),0):rotateAroundAxis(vec(0,1,0),90),# + Position,
                ang(0,0,0):rotateAroundAxis(vec(0,1,0),90),
                vec(4),0,0,Bod)
                
            }
            
        }
        
        Mesh:p2mBuild()
        
        return Mesh
        
    }
    
    function send(T:table){
        
        SignalStorage:pushTable(T)
        timer("send",1000)
        
    }
    
    function flash(E:entity,V:vector){
        
        holoCreate(HID,E:pos(),vec(1.03),E:angles(),V,E:model())
        holoMaterial(HID, "debug/debugdrawflat")
        holoAlpha(HID,100)
        holoParent(HID,E)
        HID++
        
    }
    
    function array verify(T:array){
        
        if(!T:count()){
            
            return array()
            
        }
        
        return T
        
    }
    
    function markcar(E:entity,Route:array,RteStep,NeedsHolding){

        local JobTable = Segments[Route[RteStep,string]:explode("|")[1,string],table]
        
        local CurrentLocTable = Tracks[Route[RteStep,string]:explode("|")[2,string],table]
        local FinalLocTable = Tracks[Route[Route:count(),string]:explode("|")[2,string],table]
        
        local PastLoc = Tracks[Route[RteStep-1,string]:explode("|")[2,string],table]

        
        if(NeedsHolding & PastLoc["zonemin",vector]:distance(PastLoc["zonemax",vector]) > 0){
            
            MainEntityList[E:id():toString(),table]["hold",number] = 1
            
        }
        
        if(MainEntityList[E:id():toString(),table]["hold",number] != 0){
            
            E:setCarTag("Waiting on Cars")
            E:setCarTagColor(vec(225))
            
        }else{
        
            #TODO: RE-ENABLE THIS WITH GENERIC BLOCK INDICATORS
            
            local FD = "" #"\n Pre-sort with: "+Segments[Route[RteStep,string]:explode("|")[1,string],table]["job",string] #Despite being good information, this line so confused operators that may delays and misnomers occured so I elected to remove it
            
            #TODO: MAKE TRAIN SYSTEM AFFECT THIS
            
            if(JobTable["showfinal",number] != 0){
                
                FD = "\n Final Destination: "+FinalLocTable["name",string]:replace("|\n","\n"):replace("|"," ")
    
            }
            
            local Vec = JobTable["color",vector]
            
            if(FinalLocTable["name",string] == CurrentLocTable["name",string]){
                
                FD = ""
                
                if(Route:count() == RteStep){
                    Vec = CurrentLocTable["color",vector]
                }
                
            }
            
            if(MainEntityList[E:id():toString(),table]["timer end",number] != 0){
                
                Vec = vec(220)
                
            }
            
            if(JobTable["desc",string] != ""){
                
                DSC = "\n"+JobTable["desc",string]
                
            }
    
            E:setCarTag("Next Destination: "+CurrentLocTable["name",string]:replace("|\n","\n"):replace("|"," ") + "\n Via: "+JobTable["job",string]+" "+JobTable["name",string]+DSC+FD)
            E:setCarTagColor(Vec)
            
        }
        
    }
    
    function number checksum(S1:string,S2:string,J:string){
        
        #uses an internal table to determine if 2 locations have already been linked by that job to prevent duplicates
        
        
    }
    
    #Reclassifies cars according to standard rules.
    function reclassifyCar(CarIDString:string){
        
        local CarData = MainEntityList[CarIDString,table]
        
        local Route = CarData["route",array]
        local RteStep = CarData["step",number]
        local CurrentLoc = Route[RteStep,string]:explode("|")[2,string]
    
        if(RteStep < Route:count()){ #If there's still places left to travel
            
            printM("\""+CarData["type",string]+"\" routed at "+CurrentLoc)
            CarData["step",number] = RteStep + 1
            
            markcar(entity(CarIDString:toNumber()),Route,RteStep+1,1)
            
        }else{
            
            if(Tracks[CurrentLoc,table]["delete",number] != 0){
                
                for(Y = 1,CarData["ents",array]:count()){
                    
                    entity(CarData["ents",array][Y,number]):propDelete()
                    
                }
                
                MainEntityList:remove(CarIDString)
                
            }else{
                
                local Type = rollW(Tracks[CurrentLoc,table]["reload",table][CarData["type",string],array],"")
                
                if(Tracks[CurrentLoc,table]["noreload",number]){Type = MainEntityList[CarIDString,table]["type",string]}

                local GoTo = rollW(AllDestinationsBTR[Type,array],CurrentLoc)
                            
                local NewRte = route(CurrentLoc,GoTo)

                MainEntityList[CarIDString,table] = table("type" = Type,"route" = NewRte,"ents" = CarData["ents",array],"step" = 2)
                
                markcar(entity(CarIDString:toNumber()),NewRte,2,1)
                
                send(table("name" = "renew","ent" = CarIDString))
                
                
            }
            
        }
        
    }
    
    function array rollerAdder(Roller1:array,Roller2:array,Multiplier,AddString:string){
        
        local Roller3 = Roller1:clone()
        
        #example:
        #array(6,1,"optionone",5,"optionalt")
        
        for(X = 1,(Roller2:count()-1)/2){
            
            Roller3:pushNumber(Roller2[X*2,number]*Multiplier +  Roller1[1,number])
            Roller3:pushString(Roller2[X*2+1,string]+AddString)
            
        }
        
        Roller3[1,number] = Roller1[1,number] + Roller2[1,number]*Multiplier
        
        return Roller3
        
    }
    
    ### Precalculated stuff
    
    #allows it to communicate with the carspawner with datasignals
    dsJoinGroup("operations")
    
    #starting the repeating timer for checking if cars are within triggers
    timer("scan cars",3000)
    timer("scan hold",10000)
        
    CommandStack = table()
    CommandStack:pushTable(table("command" = "first","stage" = "routebase"))
    printM("Began preprocessing.")
    
    timer("CommandStack",1000)
    
    #timer for starting timer check system
    timer("check timers",1000)
    timer("check deleted",2*60*1000)
    
    timer("reclarify",5000)
    
    K = Segments:keys()
    
    for(X = 1,K:count()){
        
        local J = K[X,string]
        local Points = Segments[J,table]["routing",table]
        
        #[
        #Within system - means trains can pick up and move cars to other industries within the pool for some other train to pick up
        for(Y = 1,Points:count()){
            
            local D2 = Points[Y,array]
            
            for(Z = 1,D2:count()){
                
                for(XX = Z+1,D2:count()){
                
                    local L1 = D2[Z,string]
                    local L2 = D2[XX,string]
                    
                    Routes[L1,array] = verify(Routes[L1,array])
                    Routes[L1,array]:pushString(J+"|"+L2+"|within")
                    
                    Routes[L2,array] = verify(Routes[L2,array])
                    Routes[L2,array]:pushString(J+"|"+L1+"|within")
                    
                }
                
            }
            
        }]#
        
        for(Y = 1,Points:count()-1){
            
            for(XY = 1,Points[Y,array]:count()){
            
                local Loc = Points[Y,array][XY,string]
                
                if(Routes[Loc,array]:count() == 0){
                    Routes[Loc,array] = array()
                }
                
                for(Z = Y,Points:count()-1){
                    
                    local P2 = Points[Z+1,array]
                    
                    for(XX = 1,P2:count()){
                    
                        if(Loc != P2[XX,string]){# & !checksum(Loc,P2[XX,string])){
                            
                             Routes[Loc,array]:pushString(J+"|"+P2[XX,string]+"|road")
                            
                        }
                        
                    }
            
                }
                
            }
            
        }
        
    }
    
    TracksToProcess = Tracks:keys()

    LocsToMark = WorldMarks:keys()
    
    runOnChat(1)

}

if(dupefinished()){reset()}

if(dsClk("markthis")){ ##MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER####MARKER##
    
    local CarspawnerDataRecieved = dsGetTable()
    
    local FrameID = CarspawnerDataRecieved[1,array][1,number]
    
    MainEntityList[FrameID:toString(),table] = MainEntityList[CarspawnerDataRecieved[2,string],table]:clone() 
    MainEntityList[FrameID:toString(),table]["ents",array] = CarspawnerDataRecieved[1,array]
    MainEntityList[FrameID:toString(),table]["starttime",number] = systime()
    
    #MainEntityList:remove(CarspawnerDataRecieved[2,string]) #remove placeholder ID
    
    if(!CarsCreatedByCommand[MainEntityList[FrameID:toString(),table]["uniquecommandid",string],array]:count()){CarsCreatedByCommand[MainEntityList[FrameID:toString(),table]["uniquecommandid",string],array] = array()}
    CarsCreatedByCommand[MainEntityList[FrameID:toString(),table]["uniquecommandid",string],array]:pushNumber(FrameID)
    
    local Route = MainEntityList[FrameID:toString(),table]["route",array]

    markcar(entity(FrameID),Route,2,1)    

    send(table("name" = "spawn","ent" = FrameID:toString()))

}elseif(dsClk("donewith")){
    
    local CarspawnerDataRecieved = dsGetString()
    
    local UniqueIDBack = CarspawnerDataRecieved:toNumber()
    
    for(Y = clamp(UniqueIDBack-5,1,inf()),UniqueIDBack){
        
        local CardsToRemove = CardsCreatedByCommand[Y:toString(),array]
    
        for(X = 1,CardsToRemove:count()){

            MainEntityList:remove(CardsToRemove[X,string])
            
        }
        
    }
    
        
    local CarsToEnable = CarsCreatedByCommand[CarspawnerDataRecieved,array]

    for(X = 1,CarsToEnable:count()){

        MainEntityList[CarsToEnable[X,number]:toString(),table]:remove("NotTracking")
        
    }
       
}

if(chatClk(owner())){ #Text parser
    
    local LSC = owner():lastSaid():lower():trim() 
    local LSCE = LSC:explode(" ")
    
    if(LSCE[1,string] == ".data"){
        
        printTable(MainEntityList[owner():aimEntity():id():toString(),table])         
        
        hideChat(1)
    #[  
    }elseif(LSCE[1,string] == ".train"){
        
        CarspawnerCommandStack = table()
        TT = 1
        
        local Count = LSCE[2,string]:toNumber()
        local Loc = LSCE[3,string]
        
        if(Loc == "all"){ #spawn trains at industries
            
            XALL = 1
            SpawnCommandsByLocation = table()
            
            UniqueCommandID++
            CommandStack:pushTable(table("command" = "allind","count" = Count,"stage" = "one","unique" = UniqueCommandID:toString()))
            
            
        }else{ #spawn trains normally
                
            local Tl = Tracks[Loc,table]
            
            if(Tl["spawnpos",vector] != vec(0) & !Tl["badspawn",number]){
                
                Adder = table()
            
                CarspawnerCommandStack[(TT):toString(),array] = array("summon",Tl["spawnpos",vector]+vec(0,0,10),Tl["spawnang",number])
                TT++
                
                UniqueCommandID++
                CommandStack:pushTable(table("command" = "train-std-1","count" = Count,"loc" = Loc,"unique" = UniqueCommandID:toString()))
                
            }else{
            
                printM("Invalid spawning location \""+Loc+"\"")
                
            }
            
        }
        
        hideChat(1)]#
        
    }elseif(LSCE[1,string] == ".cars"){
        
        CarspawnerCommandStack = table()
        TT = 1
        
        local Count = LSCE[2,string]:toNumber()
        local Spawns = LSCE[4,string]:explode("|")
        local SelectedJobs = LSCE[5,string]:explode("|")
        local Depth = LSCE[3,string]:toNumber()
        
        local LocationHash = table()
        local TrueSpawns = array()
        
        local Good = Count != 0 & Spawns:count()
        
        if(SelectedJobs[1,string] == ""){SelectedJobs = array("all")}
        
        while(Spawns:count()){
            
            local Item = Spawns[1,string]
            
            if(LocationHash[Item,number] == 0){
                
                LocationHash[Item,number] = 1
                
                local TrackData = Tracks[Item,table]
                
                if(TrackData["spawnpos",vector] != vec(0) & !TrackData["badspawn",number]){
                    
                    TrueSpawns:pushString(Item)
                    
                }
                
                foreach(Y,K:string = SpawningGroups[Item,array]){
                    
                    Spawns:pushString(K)
                    
                }
                
            }
            
            Spawns:remove(1)
            
        }

        if(Good & TrueSpawns:count() & SelectedJobs:count()){
            
            Adder = table()
            OverallSpawned = 0
            
            UniqueCommandID++
            CommandStack:pushTable(table("command" = "create cars","count" = Count,"loc" = TrueSpawns,"sortdepth" = Depth,"step" = "roller","jobs" = SelectedJobs,"unique" = UniqueCommandID:toString()))
            
            CarsRoller = array(0)
            IncrX = 1
            
        }else{
        
            printM("Invalid spawning data")
            
        }
        
        hideChat(1)
        
    }elseif(LSCE[1,string] == ".bonk"){
        
        local PlayerAimEntity = owner():aimEntity()
        
        hideChat(1)
        
        local CarData = MainEntityList[PlayerAimEntity:id():toString(),table]
        
        if(PlayerAimEntity:isValid() & CarData:count()){
            
            printM("Kicked the car to the next stage")
            
            CarData["hold",number] = 0
            
            startEntityIDTimer(PlayerAimEntity:id():toString(),0)
            
        }
        
    }elseif(LSCE[1,string] == ".reworldmark"){
        
        hideChat(1)
        printM("Removed "+WorldMarkEnts:count()+" markers and remade them.")
        
        while(WorldMarkEnts:count()){
            
            WorldMarkEnts[1,entity]:propDelete()
            WorldMarkEnts:remove(1)
            
        }
        
        LocsToMark = WorldMarks:keys()
        
    }elseif(LSCE[1,string] == ".era"){
        
        Era = LSCE[2,string]
        printM("Set era to "+Era)
        hideChat(1)
        
    }elseif(LSCE[1,string] == ".inbound"){
        
        #stoptimer("spawn inbound")
        #timer("spawn inbound",1000)
        hideChat(1)
        
    }elseif(LSCE[1,string] == ".target"){
        
        if(LSCE[2,string]:toNumber() <= 0){
            
            printM("Target Carcount is currently "+TargetCarcount)
            
        }else{
        
            TargetCarcount = LSCE[2,string]:toNumber()
            printM("Target Carcount set to "+TargetCarcount)
            
        }
        
        hideChat(1)
        
    }elseif(LSCE[1,string] == ".ohboyherewego" & owner():aimEntity() == entity()){
        
        print("We're really doing this!")
        
        hideChat(1)
        
        MainEntityList = Reload:clone()
        TimersToRecheck = MainEntityList:keys()
        Inc = IncRel

    }elseif(LSCE[1,string] == ".reloadtimers"){
        
        print("Can we do it?")
        
        hideChat(1)

        TimersToRecheck = MainEntityList:keys()

    }
    
}

if(chatClk()){
    
    if(lastSaid() == ".clarify"){
        
        local PlayerAimEntity = lastSpoke():aimEntity()
        local T2 = MainEntityList[PlayerAimEntity:id():toString(),table]
        
        if(PlayerAimEntity:isValid() & T2:count()){
            
            printM(lastSpoke():name()+" reapplied "+PlayerAimEntity:id()+"'s car marker.")
            markcar(PlayerAimEntity,T2["route",array],T2["step",number],0)
            
        }
        
    }
    
}

if(clk("reclarify")){
    
    local Keys = MainEntityList:keys()
    local CarID = Keys[randint(1,Keys:count()),string]
    local Base = entity(CarID:toNumber())
    local T2 = MainEntityList[CarID,table]

    if(Base:isValidPhysics()){
        
        markcar(Base,T2["route",array],T2["step",number],0)
        
    }
    
    timer("reclarify",500)
    
}

#[

if(clk("spawn inbound")){
    
    #timer("spawn inbound",5*60*1000)
    
    if(TargetCarcount > CurrentCarcount){
        
        printM("Queued inbound train.")

        CarspawnerCommandStack = table()
        TT = 1
        
        local Count = randint(9,14)
        local Loc = select(randint(1,2),"goldstone","daviscity")
            
        local Tl = Tracks[Loc,table]
        
        findInBox(Tl["boxlo",vector],Tl["boxhi",vector])
        findClipToClass("prop_physics")
        
        local Find = findToArray()
        
        if(!Find:count()){
            
            Adder = table()
        
            CarspawnerCommandStack[(TT):toString(),array] = array("summon",Tl["spawnpos",vector]+vec(0,0,10),Tl["spawnang",number])
            TT++
            
            UniqueCommandID++
            CommandStack:pushTable(table("command" = "train-std-1","count" = Count,"loc" = Loc,"within" = "","unique" = UniqueCommandID:toString()))
            
        }
        
    }
    
}]#


if(clk("scan cars")){ 
    
    timer("scan cars",5000)
    
    if(!CarsToScan:count()){
        CarsToScan = MainEntityList:keys()
        CurrentCarcount = StoredCarcount
        StoredCarcount = 0
    }
    
}elseif(clk("check timers")){
    
    timer("check timers",2000)
    
    while(SortedTimers[2,number] != 0 & (SortedTimers[2,number] < systime()) & safe()){
        
        
        
        local CarIDString = SortedTimers[1,string] #Name of Timer
        local CarTable = MainEntityList[CarIDString,table]
        
        
        
        MainEntityList[CarIDString,table]["timer end",number] = 0
        
        if(CarTable:count() > 0){ #if car data is Valid:
            
            local CurrentLoc = CarTable["route",array][CarTable["step",number],string]:explode("|")[2,string]
            
            reclassifyCar(CarIDString)
            
            #[
            if(Tracks[CurrentLoc,table]["zonemin",vector]:distance(Tracks[CurrentLoc,table]["zonemax",vector])){
                
                CarTable["hold",number] = 1
                
            }]#
            
        }
        
        SortedTimers:remove(1)
        SortedTimers:remove(1)
        
    }
    
}elseif(clk("scan hold")){
    
    if(!CarsToHold:count() & HoldState == ""){
        CarsToHold = MainEntityList:keys()
        JobsActive = JobsStored:clone()
        JobsStored = table()
        HoldState = "start"
        CarsAvailable = table()
        CarsReady = table()
        
    }
    
    timer("scan hold",10000)
    
}elseif(clk("check deleted")){
    
    CheckDeletions = MainEntityList:keys()
    
    timer("check deleted",0.1*60*1000)
    
}

if(ToSendOut:count() & minquota() > 3000){
    
    dsSend("populate","operations",ToSendOut)
    ToSendOut = table()
    
}

if(clk("CommandStack")){

    
    timer("CommandStack",50)

    if(CommandStack:count()){
        
        #[
        if(CommandStack[1,table]["command",string] == "train-std-1" & safe()){
            
            while(CommandStack[1,table]["count",number] & safe()){
                         
                local Type = rollW(^stock,"")
                local GoTo = rollW(AllDestinationsBTR[Type,array],CommandStack[1,table]["loc",string])
                
                local Mask = Tracks[CommandStack[1,table]["loc",string],table]["excl",string]
                
                while((Mask == Tracks[GoTo,table]["excl",string] & Mask != "") | (CommandStack[1,table]["loc",string] == GoTo)){
                        
                    Type = rollW(^stock,"")
                    GoTo = rollW(AllDestinationsBTR[Type,array],CommandStack[1,table]["loc",string])
                        
                }
                
                local Route = route(CommandStack[1,table]["loc",string],GoTo)                 
                    
                #mechanism that generates an "Index" for each track, allowing sorting  
                local Index = CommandStack[1,table]["loc",string]
                
                for(X = 1,Route:count()){
                    
                    Index = Index + Route[X,string]
                    
                }
                
                
                for(Y = 1,Adder:count()+1){
                    
                    if(Index > Adder[Y,array][4,string]){
                    
                        local TempID = "ph"+PlaceholderID
                        local UniqueID = CommandStack[1,table]["unique",string]
                        
                        MainEntityList[TempID,table] = table("type" = Type,"route" = Route,"NotTracking" = 1,"uniquecommandid" = UniqueID,"step" = 2)
                        
                        
                        if(!CardsCreatedByCommand[UniqueID,array]:count()){CardsCreatedByCommand[UniqueID,array] = array(TempID)}else{CardsCreatedByCommand[UniqueID,array]:pushString(TempID)}
                        PlaceholderID++
                        
                        Adder:insertArray(Y,array(".sp 0 "+Era+" "+Type,vec(distrand(3,3),0,0),TempID,Index))
                        
                        
                        break
                        
                    }
                     
                }
                
                CommandStack[1,table]["count",number] = CommandStack[1,table]["count",number] - 1
                
            }
            
            if(!CommandStack[1,table]["count",number]){
                
                for(X = 1,Adder:count()){
                    
                    Adder[X,array]:remove(4)
                    
                    CarspawnerCommandStack[(TT):toString(),array] = Adder[X,array]
                    TT++
                    
                }
                
                CarspawnerCommandStack[(TT):toString(),array] = array("summon",vec(0),0)
                TT++
                CarspawnerCommandStack[(TT):toString(),string] = CommandStack[1,table]["unique",string]
                
                send(table("name" = "train","unique" = CommandStack[1,table]["unique",string]))
                
                ToSendOut = CarspawnerCommandStack
            
                printM("spawned train length "+Adder:count()+" at "+CommandStack[1,table]["loc",string])
                
                CommandStack:remove(1)
                
            }
            
        }else]#
        
        if(CommandStack[1,table]["command",string] == "create cars" & safe()){
            
            if(CommandStack[1,table]["step",string] == "roller" & safe()){
                
                while(IncrX <= CommandStack[1,table]["loc",array]:count() & safe()){
                    
                    local CurrentLoc = CommandStack[1,table]["loc",array][IncrX,string]
                    local TrafficLoc = Tracks[CurrentLoc,table]["part of",string] != "" ? Tracks[CurrentLoc,table]["part of",string] : CurrentLoc
                    
                    local Base = 1
                    
                    if(Tracks[CurrentLoc,table]["length",number] != 0 & Tracks[CurrentLoc,table]["part of",string] != ""){
                        
                        Base = Tracks[CurrentLoc,table]["length",number] / Tracks[Tracks[CurrentLoc,table]["part of",string],table]["total length",number]
                        
                    }
                
                    if(CommandStack[1,table]["jobs",array][1,string] == "all"){
                        
                        local Traffic = Tracks[TrafficLoc,table]["traffic",table]
                        local TrafficKeys = Traffic:keys()
                        
                        for(X = 1,TrafficKeys:count()){
                            
                            CarsRoller = rollerAdder(CarsRoller,Traffic[TrafficKeys[X,string],array],Base,"|"+CurrentLoc)
                            
                        }
                        
                    }else{

                        TrafficKeys = CommandStack[1,table]["jobs",array]
                        
                        for(X = 1,TrafficKeys:count()){
                        
                            CarsRoller = rollerAdder(CarsRoller,Tracks[TrafficLoc,table]["traffic",table][TrafficKeys[X,string],array],Base,"|"+CurrentLoc)
                            
                        }
                        
                    }
                    
                    IncrX++
                    
                }
                
                if(IncrX > CommandStack[1,table]["loc",array]:count()){
                    
                    if(CarsRoller:count() > 1){
                    
                        CommandStack[1,table]["step",string] = "complete"
                        CommandStack[1,table]["step2",string] = "first"
                        
                    }else{
                        
                        CommandStack:remove(1)
                        printM("Cars process found nothing")
                        
                    }
                    
                    IncrX = 1
                    IncrY = 1
                    
                }
                
            }
                        
            if(CommandStack[1,table]["step",string] == "complete" & safe()){
            
                while(CommandStack[1,table]["count",number] & safe() & perf()){
                    
                    #Sector1 = maxquota():toString()+" "+systime()+" "+safe()
                    
                    if(CommandStack[1,table]["step2",string] == "first" & safe()){
                    
                        ToSpawnData = rollW(CarsRoller,""):explode("|")
                        CommandStack[1,table]["step2",string] = "route"
                        
                    }
                        
                    if(CommandStack[1,table]["step2",string] == "route" & minquota() > 5000){
                        
                        #Sector2 = maxquota():toString()+" "+systime()+" "+safe()
                        
                        local Type = ToSpawnData[2,string]
                        local GoTo = ToSpawnData[3,string]
                        local Loc = ToSpawnData[4,string]
                    
                        local Route = route(Loc,GoTo)                
                            
                        #mechanism that generates an "Index" for each track, allowing sorting  
                        local Index = Loc
    
                        for(X = 1,clamp(Route:count(),0,CommandStack[1,table]["sortdepth",number])){
                            
                            Index = Index + Route[X,string]
                            
                        }
                        
                        #Sector3 = maxquota():toString()+" "+systime()+" "+safe()
                        
                        if(!Adder[Loc,table]:count()){
                            
                            Adder[Loc,table] = table()
                            
                        }
                        
                        SavedSpawnData = table(Loc,Index,Route,Type)
                        
                        CommandStack[1,table]["step2",string] = "second"
                        
                    }
                    
                    if(CommandStack[1,table]["step2",string] == "second" & safe()){
                        
                        local Loc = SavedSpawnData[1,string]
                        local Index = SavedSpawnData[2,string]
                        local Route = SavedSpawnData[3,array]
                        local Type = SavedSpawnData[4,string]  
                        
                        
                        
                        #Sector4 = maxquota():toString()+" "+systime()+" "+safe()
                    
                        while(IncrY <= Adder[Loc,table]:count()+1 & safe()){
                            
                            if(Index >= Adder[Loc,table][IncrY,array][4,string]){
                            
                                local TempID = "ph"+PlaceholderID
                                local UniqueID = CommandStack[1,table]["unique",string]
                                
                                MainEntityList[TempID,table] = table("type" = Type,"route" = Route,"NotTracking" = 1,"uniquecommandid" = UniqueID,"step" = 2)
                                
                                
                                if(!CardsCreatedByCommand[UniqueID,array]:count()){CardsCreatedByCommand[UniqueID,array] = array(TempID)}else{CardsCreatedByCommand[UniqueID,array]:pushString(TempID)}
                                PlaceholderID++
                                
                                local CarspawnerCompatibleType = (Type:explode("-")[1,string] +" "+ ((Type:find("empty") != 0) ? "empty" : "loaded"))
                                
                                Adder[Loc,table]:insertArray(IncrY,array(".sp 0 "+Era+" "+CarspawnerCompatibleType,vec(distrand(3,3),0,0),TempID,Index))
                                
                                IncrY = Adder[Loc,table]:count()+1
                                
                            }
                            
                            IncrY++
                             
                        }
                        
                        #Sector5 = maxquota():toString()+" "+systime()+" "+safe()
                        
                        if(IncrY >= Adder[Loc,table]:count()+1){ 
                            
                            IncrY = 1
                            CommandStack[1,table]["count",number] = CommandStack[1,table]["count",number] - 1
                            OverallSpawned++
                            CommandStack[1,table]["step2",string] = "first"
                            
                            #Sector6 = maxquota():toString()+" "+systime()+" "+safe()
                            
                        }
                        
                    }
                    
                }
                
                #Sector7 = maxquota():toString()+" "+systime()+" "+safe()
            
                if(!CommandStack[1,table]["count",number]){
                    
                    CommandStack[1,table]["step",string] = "finalize"
                    IncrX = 1
                    IncrY = 1
                    TracksKeys = Adder:keys()
                    
                }
                
            }
            
            #Sector8 = maxquota():toString()+" "+systime()+" "+safe()
            
            if(CommandStack[1,table]["step",string] == "finalize" & safe()){
                
                while(IncrX <= TracksKeys:count() & safe()){
                    
                    local TrackData = Tracks[TracksKeys[IncrX,string],table]
                    
                    CarspawnerCommandStack[(TT):toString(),array] = array("summon",TrackData["spawnpos",vector]+vec(0,0,20),TrackData["spawnang",number])
                    TT++
                    
                    local Loc = TracksKeys[IncrX,string]
                    
                    for(X = 1,Adder[Loc,table]:count()){
                        #[
                        local PrevCar = CarspawnerCommandStack[(TT-1):toString(),array]
                        #currently all cars need a unique carspawner command to correctly send the pre-tag information; so this is botched for now
                        if(Adder[Loc,table][X,array][4,string] == PrevCar[4,string] & PrevCar[4,string] != "" & Adder[Loc,table][X,array][1,string] == PrevCar[1,string]){
                            
                            CarspawnerCommandStack[(TT-1):toString(),array][3,vector] = PrevCar[3,vector] + Adder[Loc,table][X,array][3,vector]
                            
                        }else{]#
                        
                        CarspawnerCommandStack[(TT):toString(),array] = Adder[Loc,table][X,array]
                        TT++
                            
                        #}
                        
                    }
                    
                    IncrX++
                    
                }
                
                if(IncrX > TracksKeys:count()){
                
                    CarspawnerCommandStack[(TT):toString(),array] = array("summon",vec(0),0)
                    TT++
                    CarspawnerCommandStack[(TT):toString(),string] = CommandStack[1,table]["unique",string]
                    
                    send(table("name" = "train","unique" = CommandStack[1,table]["unique",string]))
                    
                    ToSendOut = CarspawnerCommandStack
                
                    printM("spawned "+OverallSpawned+" cars at "+toString(TracksKeys))
                    OverallSpawned = 0
                    IncrX = 1
                    
                    CommandStack:remove(1)
                    
                }
                
                
            }
            
        }elseif(CommandStack[1,table]["command",string] == "first" & safe()){
                
            #pull out types from Tracks and use them to lay the foundation for the router
            
            if(CommandStack[1,table]["stage",string] == "routebase" & safe()){
        
                while(TracksToProcess:count() & safe()){
                    
                    local TrackName = TracksToProcess[1,string]
                    local TrackData = Tracks[TrackName,table]
                    
                    if(TrackData["color",vector] != vec(0)){
                        
                        TrackData["color",vector] = clamp(TrackData["color",vector],vec(0),vec(255))
                        
                    }
                    
                    if(TrackData["work",array]:count() & TrackData["time",number] == 0){
                        
                        TrackData["time",number] = IndTurn
                        
                    }
                    
                    if(TrackData["work",array]:count() % 4 != 0){error(J+"'s work isn't set up correctly!")}
                
                    if(!Routes[TrackName,array]:count() & TrackData["part of",string] == ""){
                        
                        TrackData["badspawn",number] = 1
                        
                    }
                    
                    TrackData["pretraffic",table] = table()
                    TrackData["reload",table] = table()
                    
                    local WorkData = TrackData["work",array]
                    
                    for(Y = 1,WorkData:count()/4){
                        
                        local CarType = WorkData[Y*4-2,string]+"-"+WorkData[Y*4-1,string]
                        
                        LocalDestinationsBTR[CarType,array] = array(0)
                        LocalSourcesBTR[CarType,array] = array(0)
                        LocalDestinationsBTR[WorkData[Y*4-2,string]+"-"+WorkData[Y*4,string],array] = array(0)
                        LocalSourcesBTR[WorkData[Y*4-2,string]+"-"+WorkData[Y*4,string],array] = array(0)
                        
                        if(!TrackData["reload",table][CarType,array]:count()){
                            
                            TrackData["reload",table][CarType,array] = array(0)
                            
                        }
                        
                        TrackData["reload",table][CarType,array][1,number] = TrackData["reload",table][CarType,array][1,number] + WorkData[Y*4-3,number]
                        TrackData["reload",table][CarType,array]:pushNumber(TrackData["reload",table][CarType,array][1,number])
                        TrackData["reload",table][CarType,array]:pushString(WorkData[Y*4-2,string]+"-"+WorkData[Y*4,string])
                        
                    }
                    
                    if(WorkData:count() & TrackData["delete",number] != 1 & TrackData["not a destination",number] != 1){
                        
                        if(!SpawningGroups["allind",array]:count()){
                            
                            SpawningGroups["allind",array] = array()
                            
                        }
                        
                        #printTable(TrackData["reload",table]),print(TrackName)
                        SpawningGroups["allind",array]:pushString(TrackName)
                        
                    }
                    
                    local PartOf = TrackData["part of",string]
                    
                    if(PartOf != ""){
                        
                        Tracks[PartOf,table]["total length",number] = Tracks[PartOf,table]["total length",number] + TrackData["length",number]
                    
                        if(!SpawningGroups[PartOf,array]:count()){
                            
                            SpawningGroups[PartOf,array] = array()
                            
                        }
                        
                        SpawningGroups[PartOf,array]:pushString(TrackName)
                        
                    }
                    
                    local LocGroup = TrackData["locgroup",string]
                    
                    if(LocGroup != ""){
                    
                        if(!SpawningGroups[LocGroup,array]:count()){
                            
                            SpawningGroups[LocGroup,array] = array()
                            
                        }
                        
                        SpawningGroups[LocGroup,array]:pushString(TrackName)
                        
                    }
                    
                    if(Tracks[TrackName,table]["shareall",number] > 0){
                        
                        ShareAllRoller[1,number] = ShareAllRoller[1,number] + TrackData["shareall",number]
                        ShareAllRoller = ShareAllRoller:add(array(ShareAllRoller[1,number],TrackName))
                        
                    }
                    
                    if(TrackData["inbound",number] > 0){
    
                        InboundTracksRoller[1,number] = InboundTracksRoller[1,number] + TrackData["inbound",number]
                        InboundTracksRoller = InboundTracksRoller:add(array(InboundTracksRoller[1,number],TrackName))
                        
                    }
                    
                    if(TrackData["outbound",number] > 0){
                        
                        OutboundTracksRoller[1,number] = OutboundTracksRoller[1,number] + TrackData["outbound",number]
                        OutboundTracksRoller = OutboundTracksRoller:add(array(OutboundTracksRoller[1,number],TrackName))
                        
                    }
                    
                    TracksToProcess:remove(1)
                    
                }
                
                if(!TracksToProcess:count()){
                
                    CarTypesList = LocalDestinationsBTR:keys()
                    
                    TracksKeys = Tracks:keys()
                    
                    #vars for test train spawn (see below)
                    CarspawnerCommandStack = table()
                    TT = 1
                    
                    CommandStack[1,table]["stage",string] = "tracks"
                    Xt = 1
                    
                }
                
            }
            
            if(CommandStack[1,table]["stage",string] == "tracks" & safe()){
                
                while(Xt <= TracksKeys:count() & holoCanCreate() & safe()){
                    
                    Index = TracksKeys[Xt,string]
                    local Tl = Tracks[Index,table]
                    
                    local P = Tl["boxhi",vector]
                    local N = Tl["boxlo",vector]
                    local R = Tl["boxrot",number]
                    
                    local C = ((P+N)*0.5)
                
                    local C2 = C:rotateAroundAxis(vec(0,0,1),R)
                    
                    Tl["boxhi",vector] = C2+(P-C)
                    Tl["boxlo",vector] = C2-(P-C)
                    
                    local Sc = newabs((1/2048)*(Tl["boxlo",vector]-Tl["boxhi",vector]))
                
                    #[marks the trigger zones with boxes
                    holoCreate(HID,C,Sc,ang(0,0,0):rotateAroundAxis(vec(0,0,1),-R),Tl["color",vector],"models/props_metaladon/parts/boundingbox.mdl")
                    holoAlpha(HID,70)
                    holoMaterial(HID,"debug/debugdrawflat")
                    HID++
                    #]#
                    
                    local WorkInfo = Tl["work",array]
                    
                    for(Y = 1,WorkInfo:count()/4){
                        
                        local Weight = WorkInfo[Y*4-3,number]
                        #local CarType = WorkInfo[Y*4-2,string]
                        #local Load = WorkInfo[Y*4-1,string]
                        #local Reload = WorkInfo[Y*4,string]
                        
                        if(Tl["not a destination",number] == 0){
                        
                            local TrueType = WorkInfo[Y*4-2,string]+"-"+WorkInfo[Y*4-1,string]
                            
                            LocalDestinationsBTR[TrueType,array]:pushNumber(LocalDestinationsBTR[TrueType,array][1,number] + Weight)
                            LocalDestinationsBTR[TrueType,array]:pushString(Index)
                            LocalDestinationsBTR[TrueType,array][1,number] = LocalDestinationsBTR[TrueType,array][1,number] + Weight
                            
                        }
                        
                        if(!Tl["delete",number]){
                            
                            local TrueType = WorkInfo[Y*4-2,string]+"-"+WorkInfo[Y*4,string]
                        
                            LocalSourcesBTR[TrueType,array]:pushNumber(LocalSourcesBTR[TrueType,array][1,number] + Weight)
                            LocalSourcesBTR[TrueType,array]:pushString(Index)
                            LocalSourcesBTR[TrueType,array][1,number] = LocalSourcesBTR[TrueType,array][1,number] + Weight
                            
                        }
                        
                    }
                    
                    Xt++
                    
                    
                }
                
                if(Xt > TracksKeys:count()){
                    
                    CommandStack[1,table]["stage",string] = "interchange1" 
                    IncrX = 1
                    
                    #printTable(LocalDestinationsBTR)
                    #printTable(LocalSourcesBTR)

                }

            }
            
            if(CommandStack[1,table]["stage",string] == "interchange1" & safe()){
                
                while(IncrX <= CarTypesList:count() & safe()){
                    
                    local CarType = CarTypesList[IncrX,string]
                    
                    TrafficRatiobyType[CarType,table] = table()
                    FromTrafficRatiobyType[CarType,table] = table()
                    
                    local CarVolumeGap = LocalDestinationsBTR[CarType,array][1,number] - LocalSourcesBTR[CarType,array][1,number] 
                    
                    if(CarVolumeGap < 0){ #if there's more suppliers than takers
                         
                        local Base = -CarVolumeGap / OutboundTracksRoller[1,number]
                        
                        if(Base < 0){error("stanky negative bases")}
                                                                                   
                        AllDestinationsBTR[CarType,array] = rollerAdder(LocalDestinationsBTR[CarType,array],OutboundTracksRoller,Base,"")
                        
                        AllSourcesBTR[CarType,array] = LocalSourcesBTR[CarType,array]
                        
                    }else{
                        
                        if(CarVolumeGap != 0){
                        
                            local Base = CarVolumeGap / InboundTracksRoller[1,number]
                                    
                            AllSourcesBTR[CarType,array] = rollerAdder(LocalSourcesBTR[CarType,array],InboundTracksRoller,Base,"")
                            
                        }else{
                            
                            AllSourcesBTR[CarType,array] = LocalSourcesBTR[CarType,array]
                            
                        }
        
                        AllDestinationsBTR[CarType,array] = LocalDestinationsBTR[CarType,array]
                        
                        
                    }
                    
                    local Base = AllDestinationsBTR[CarType,array][1,number] #doesn't matter which from,to,swap,not you take it from; they're all the same; as long as it's defined
                    
                    if(Base == 0){
                        
                        error("I accidentally did a bad logic, this might be a major issue")
                        
                    }
                    
                    AllDestinationsBTR[CarType,array] = rollerAdder(AllDestinationsBTR[CarType,array],ShareAllRoller,Base,"")
                    AllSourcesBTR[CarType,array] = rollerAdder(AllSourcesBTR[CarType,array],ShareAllRoller,Base,"")
                    
                    IncrX++
                    
    
                }
                
                if(IncrX > CarTypesList:count()){
                
                    TypeIncr = 1
                    IncrX = 1
                    IncrY = 1
                    
                    #[
                    print("!!!!!!!!!!!!!!!!!!!!!!!!!!!")
                    printTable(AllSourcesBTR)
                    print("~~~~~~~~~~~~~~~~~~~~~~~~~~")
                    printTable(AllDestinationsBTR)
                    #]#
                    
                    CommandStack[1,table]["stage",string] = "interchange2"
                    
                }
                
            }
            
            if(CommandStack[1,table]["stage",string] == "interchange2" & safe()){
                
                while(IncrX <= CarTypesList:count() & safe()){
                    
                    local CarType = CarTypesList[IncrX,string]
                
                    local TotalTraffic = AllSourcesBTR[CarType,array][1,number]
                    
                    for(X = 1,(AllDestinationsBTR[CarType,array]:count()-1)/2){
                        
                        local Roller = AllDestinationsBTR[CarType,array]
                        local Weight = Roller[X*2,number]-Roller[X*2-2,number]
                        local Location = Roller[X*2+1,string]
                    
                        TrafficRatiobyType[CarType,table][Location,number] = Weight/TotalTraffic
                        
                    }
                    
                    for(X = 1,(AllSourcesBTR[CarType,array]:count()-1)/2){
                        
                        local Roller = AllSourcesBTR[CarType,array]
                        local Weight = Roller[X*2,number]-Roller[X*2-2,number]
                        local Location = Roller[X*2+1,string]
                        
                        FromTrafficRatiobyType[CarType,table][Location,number] = Weight
                        
                    }
                    
                    IncrX++
                    
                }
                
                if(IncrX > CarTypesList:count()){
                    
                    TypeIncr = 1
                    IncrX = 1
                    IncrY = 1
                    
                    CommandStack[1,table]["stage",string] = "traffic1"
                    
                }
                
                
            }
            
            if(CommandStack[1,table]["stage",string] == "traffic1" & safe()){
                
                while(TypeIncr <= CarTypesList:count() & safe()){
                    
                    local CarType = CarTypesList[TypeIncr,string]
                    
                    local ToPos = AllDestinationsBTR[CarType,array]
                    local FromPos = AllSourcesBTR[CarType,array]
                    
                    #print(CarType,ToPos,FromPos)
                    
                    while(IncrX <= (FromPos:count()-1)/2 & safe()){
                        
                        local From = FromPos[IncrX*2+1,string]
                        
                        if(!Tracks[From,table]["badspawn",number]){
                        
                            while(IncrY <= (ToPos:count()-1)/2 & safe()){
                            
                                local To = ToPos[IncrY*2+1,string]
                            
                                if(From != To & ((Tracks[From,table]["excl",string] != Tracks[To,table]["excl",string]) | Tracks[To,table]["excl",string] == "")  & Tracks[From,table]["name",string] != Tracks[To,table]["name",string]){
                                    
                                    Pairs = +Pairs+", "+From+">"+To
                                    local RouteInfo = route(From,To)
                                    
                                    if(RouteInfo:count() < 2){print(From+" "+To+" failed!")}
                                    
                                    #local TodoS = CarType+": "+From+">"+To+" "
                                    local StoredLoc = From
                                    
                                    for(X = 2,RouteInfo:count()){
                                        
                                        local Segment = RouteInfo[X,string]:explode("|")[1,string]
                                        local TrackRoller = Tracks[StoredLoc,table]["pretraffic",table][Segment,table]
                                        local SaveData = Segment+"|"+CarType+"|"+To
                                        
                                        if(!TrackRoller:count()){
                                            
                                            TrackRoller = table()
                                            Tracks[StoredLoc,table]["pretraffic",table][Segment,table] = TrackRoller
                                            
                                        }
                                        
                                        TrackRoller[SaveData,number] = TrackRoller[SaveData,number] + TrafficRatiobyType[CarType,table][To,number] * FromTrafficRatiobyType[CarType,table][From,number] # multiplied by the weight of this car type overall
                                        
                                        StoredLoc = RouteInfo[X,string]:explode("|")[2,string]
                                        
                                    }
                                    
                                }
                                
                                IncrY++
                                
                            }
                            
                        }
                        
                        if(IncrY > (ToPos:count()-1)/2 | Tracks[From,table]["badspawn",number]){
                            
                            IncrY = 1
                            IncrX++
                            
                        }
    
                        
                    }
                         
                        
                    if(IncrX > (FromPos:count()-1)/2){
                        
                        IncrX = 1
                        TypeIncr++
                        #if(Pairs != ""){printM(CarType + ""+Pairs)}
                        Pairs = ""
    
                        
                    }       
                    
                }
                
                if(TypeIncr > CarTypesList:count()){
                    
                    CommandStack[1,table]["stage",string] = "traffic2"
                    TypeIncr = 1
                    IncrX = 1
                    
                    
                }
                
            }
            
            if(CommandStack[1,table]["stage",string] == "traffic2" & safe()){
                
                local TrackKeys = Tracks:keys()
                
                while(IncrX <= TrackKeys:count() & safe()){
                    
                    local Traffic = Tracks[TrackKeys[IncrX,string],table]["pretraffic",table]
    
                    Tracks[TrackKeys[IncrX,string],table]["traffic",table] = table()
    
                    local TrafficKeys = Traffic:keys()
                    
                    for(X = 1,TrafficKeys:count()){
                        
                        local Roller = array(0)
                        
                        local SegmentData = Traffic[TrafficKeys[X,string],table]
                        local SegmentKeys = SegmentData:keys()
                        
                        for(Y = 1,SegmentKeys:count()){
                        
                            local Choice = SegmentKeys[Y,string]
                            Roller[1,number] = Roller[1,number] + SegmentData[Choice,number]
                            Roller:pushNumber(Roller[1,number])
                            Roller:pushString(Choice)
                            
                        }
                        
                        Tracks[TrackKeys[IncrX,string],table]["traffic",table][TrafficKeys[X,string],array] = Roller
                        
                        Tracks[TrackKeys[IncrX,string],table]:remove("pretraffic")
                    }
                    
                    
                    
                    
                    
                    IncrX++
                    
                }
                
                if(IncrX > TrackKeys:count()){
                    
                    CommandStack:remove(1) 
                    printM("Completed main calculations.")
                    
                }
                
            }
            
        }
        #[ 
        }elseif(CommandStack[1,table]["command",string] == "allind" & safe()){
            
            if(CommandStack[1,table]["stage",string] == "one" & safe()){
            
                while(XALL <= CommandStack[1,table]["count",number] & safe()){
                    
                    local Type = "broken" #rollW(^stock,"")
                    local Loc2 = rollW(LocalDestinationsBTR[Type,array],"")
                    
                    local Type = rollW(Tracks[Loc2,table]["reload",table][Type,array],"")
                    
                    local Mask = Tracks[Loc2,table]["excl",string]
                    local GoTo = rollW(AllDestinationsBTR[Type,array],Loc2)
                    
                    while(Mask == Tracks[GoTo,table]["excl",string] & Mask != ""){
                        
                        GoTo = rollW(AllDestinationsBTR[Type,array],Loc2)
                        
                    }
                    
                    if(SpawnCommandsByLocation[Loc2,table]:count() == 0){
                        
                        SpawnCommandsByLocation[Loc2,table] = table()
                        
                    }    
                    
                    local Route = route(Loc2,GoTo)
                    
                    
                    local TempID = "ph"+PlaceholderID
                    local UniqueID = CommandStack[1,table]["unique",string]
                    
                    MainEntityList[TempID,table] = table("type" = Type, "route" = Route, "NotTracking" = 1, "uniquecommandid" = UniqueID,"step" = 2)
                    if(!CardsCreatedByCommand[UniqueID,array]:count()){CardsCreatedByCommand[UniqueID,array] = array(TempID)}else{CardsCreatedByCommand[UniqueID,array]:pushString(TempID)}
                    PlaceholderID++
                    
                    SpawnCommandsByLocation[Loc2,table]:pushArray(array(".sp 0 "+Era+" "+Type,vec(distrand(3,3),0,0),TempID))
                    
                    GoTo+"|"+Loc2+"|"+Type
                    
                    XALL++
        
                }
                
                if(XALL > CommandStack[1,table]["count",number]){
                    
                    TracksKeys = SpawnCommandsByLocation:keys()
                    CommandStack[1,table]["stage",string] = "two"
                    XALL = 1
                    
                }
                
            }
            
            if(CommandStack[1,table]["stage",string] == "two" & safe()){
            
                while(XALL <= TracksKeys:count() & safe()){
                    
                    local Tl = Tracks[TracksKeys[XALL,string],table]
                    
                    CarspawnerCommandStack[(TT):toString(),array] = array("summon",Tl["spawnpos",vector]+vec(0,0,20),Tl["spawnang",number])
                    TT++
                    
                    local Add = SpawnCommandsByLocation[TracksKeys[XALL,string],table]
                    
                    for(Y = 1,Add:count()){
                        
                        CarspawnerCommandStack[(TT):toString(),array] = Add[Y,array]
                        TT++
                        
                    }
                    
                    XALL++
                    
                }
                
                if(XALL > TracksKeys:count()){
                    
                    CarspawnerCommandStack[(TT):toString(),array] = array("summon",vec(0),0)
                    TT++
                    CarspawnerCommandStack[(TT):toString(),string] = CommandStack[1,table]["unique",string]
                    
                    ToSendOut = CarspawnerCommandStack
                    
                    printM("spawned "+CommandStack[1,table]["count",number]+" cars at \"all industries\"")
                    
                    CommandStack:remove(1)
                    
                }
                
            }
            
            
        }]#
        
    }

    while(safe() & CarsToScan:count()){
        
        if(CarsToScan[1,string]:toNumber() != 0 & MainEntityList[CarsToScan[1,string],table]["NotTracking",number] != 1){
        
            local CarTable = MainEntityList[CarsToScan[1,string],table]
            
            local Route = CarTable["route",array]
            local RteStep = CarTable["step",number]
            
            StoredCarcount = StoredCarcount + 1
            
            if(CarTable["timer end",number] == 0 & CarTable["hold",number] == 0 & within(entity(CarTable["ents",array][1,number]):pos(),Route[RteStep,string]:explode("|")[2,string])){
                
                local IsGoingOffMap = Tracks[Route[RteStep,string]:explode("|")[2,string],table]["delete",number] != 0
                startEntityIDTimer(CarsToScan[1,string],1)
                send(table("name" = "reroute","ent" = CarsToScan[1,string],"where" = CarTable["route",array][RteStep,string]:explode("|")[2,string],"count" = ((Route:count()-RteStep)+1),"isoffmap" = IsGoingOffMap))
                if(IsGoingOffMap){MainEntityList[CarsToScan[1,string],table]["out",number] = 1}
                
            }
            
        }
        
        CarsToScan:remove(1)
    
    }
    
    while(safe() & CarsToHold:count() & HoldState == "start"){
        
        if(CarsToHold[1,string]:toNumber() != 0 & MainEntityList[CarsToHold[1,string],table]["NotTracking",number] != 1){
        
            local CarTable = MainEntityList[CarsToHold[1,string],table]
            local Route = CarTable["route",array]
            local CurrentJob = Route[CarTable["step",number],string]:explode("|")[1,string]
            local CurrentLoc = CarTable["route",array][CarTable["step",number]-1,string]:explode("|")[2,string]
            
            if(CarTable["timer end",number] == 0){JobsStored[CurrentJob,number] = JobsStored[CurrentJob,number] + 1}
            
            local ZoneMax = Tracks[CurrentLoc,table]["zonemax",vector]
            local ZoneMin = Tracks[CurrentLoc,table]["zonemin",vector]
            
            if(boxed(ZoneMax,ZoneMin,entity(CarTable["ents",array][1,number]):pos())){
                
                local TrainToGoOut = Segments[CurrentJob,table]["train",string]
            
                if(CarTable["hold",number]){
                    
                    local BlockMin = Segments[CurrentJob,table]["min",number]
                    local BlockMax = Segments[CurrentJob,table]["max",number]
                    local TrainMin = Trains[TrainToGoOut,table]["min",number]
                    local TrainMax = Trains[TrainToGoOut,table]["max",number]
                    
                    ToEvaluate:pushTable(table(CarsToHold[1,string],BlockMin,BlockMax,TrainMin,TrainMax,CurrentLoc,CurrentJob))
                    
                }
                
                #flash(entity(CarTable["ents",array][1,number]),vec(0,255,0))
                
                
                if(!CarsAvailable[CurrentLoc,table]:count()){
                    CarsAvailable[CurrentLoc,table] = table()
                }
                
                increment(CarsAvailable[CurrentLoc,table],CurrentJob,1)
                if(TrainToGoOut != ""){increment(CarsAvailable[CurrentLoc,table],TrainToGoOut,1)}
                
                if(!CarTable["hold",number]){
                    
                    if(!CarsReady[CurrentLoc,table]:count()){
                        CarsReady[CurrentLoc,table] = table()
                    }
                    
                    increment(CarsReady[CurrentLoc,table],CurrentJob,1)
                    if(TrainToGoOut != ""){increment(CarsReady[CurrentLoc,table],TrainToGoOut,1)}
                    
                }
                
            }elseif(CarTable["hold",number]){
                
                MainEntityList[CarsToHold[1,string],table]["hold",number] = 0
                markcar(entity(CarsToHold[1,string]:toNumber()),Route,CarTable["step",number],0)
                
            }
                
        }
        
        CarsToHold:remove(1)
        
    }
    
    if(!CarsToHold:count() & HoldState == "start"){
        
        HoldState = "blocks"
        BlockIncrX = 1
        LocationKeys = CarsAvailable:keys()
        BlocksOK = table()
        
    }
    
    while(HoldState == "blocks" & safe() & BlockIncrX <= CarsAvailable:count()){
        
        local CurrentLoc = LocationKeys[BlockIncrX,string]
        local Blocks = CarsAvailable[CurrentLoc,table]
        
        for(Y = 1,Blocks:count()){
            
            local CurrentJob = Blocks:keys()[Y,string]
        
            local A = (Segments[CurrentJob,table]["min",number] == 0 | CarsAvailable[CurrentLoc,table][CurrentJob,number] >= Segments[CurrentJob,table]["min",number])
            
            if(!BlocksOK[CurrentLoc,table]:count()){
                BlocksOK[CurrentLoc,table] = table()
            }
            
            local Train = Segments[CurrentJob,table]["train",string]
                
            if(Train != ""){
                
                if(!BlocksOK[CurrentLoc,table][Train,table]:count()){
                    BlocksOK[CurrentLoc,table][Train,table] = table()   
                }
                    
                if(A){increment(BlocksOK[CurrentLoc,table][Train,table],"tilmin",CarsAvailable[CurrentLoc,table][CurrentJob,number])}
                increment(BlocksOK[CurrentLoc,table][Train,table],"tilmax",CarsReady[CurrentLoc,table][CurrentJob,number])
                
                #here's why we need both. This cycle, the train needs to know 2 things: Do I have enough cars to meet the minimum, and how many cars do I have currently counting against the maximum?
                #"tilmin" adds up all the cars that could be available AND are guarenteed to have enough to leave;
                #"tilmax" adds up the currently marked cars, so when adding additional cars it knows how many the train already posesses and won't go over.
                
            }

        }
        
        BlockIncrX++
        
    }
    
    if(HoldState == "blocks" & BlockIncrX > CarsAvailable:count()){
        
        HoldState = "process"
        
        #printTable(BlocksOK["wolfram",table])
        
    }
    
    while(ToEvaluate:count() & HoldState == "process" & safe()){
        
        local CarToEval = ToEvaluate[1,table]
        
        #block minimum check (do I have enough to meet X)
        #block maximum check (will this put me over y)
        #train minimum check (do I have enough to meet X)
        #train maximum check (will this put me over y)
        #min-max check (does the number of cars in the train minus this specific block plus the minimum of this block equal more than the maximum of the train?)
        
        #need a 5th check for "do I have enough cars to satisfy the block AND train minimums for this block"
        #meant to avoid a situation where a train "sends out" a block and 2 half-blocks; the full block sees it has "enough cars" for a train, and the half-blocks haven't met their minimums yet
        
        local Train = Segments[CarToEval[7,string],table]["train",string]
        
        local BlockMin = CarToEval[2,number]
        local BlockMax = CarToEval[3,number]
        local TrainMin = CarToEval[4,number]
        local TrainMax = CarToEval[5,number]
        
        local Location = CarToEval[6,string]
        local Segment = CarToEval[7,string]
    
        local ApprovedMin = BlocksOK[Location,table][Train,table]["tilmin",number]
        local ApprovedMax = BlocksOK[Location,table][Train,table]["tilmax",number]
        
        local Ready = CarsReady[Location,table][Segment,number]
        local Available = CarsAvailable[Location,table][Segment,number]
        
        #printTable(CarsReady)
        #print(Ready+" "+Location+" "+Segment)
        
        local A = !BlockMin | (Available >= BlockMin)
        local B = !BlockMax | (Ready < BlockMax)
        local C = !TrainMin | (ApprovedMin >= TrainMin)
        local D = !TrainMax | (ApprovedMax < TrainMax)
        
        local E = ((Train == "" | !TrainMax | !BlockMin) | ((ApprovedMax - Ready + BlockMin) < TrainMax))
        
        if(A+B+C+D+E == 5){
            
            if(!CarsReady[Location,table]:count()){
                CarsReady[Location,table] = table()
            }
            
            if(!BlocksOK[Location,table]:count()){
                BlocksOK[Location,table] = table()
            }
            
            increment(CarsReady[Location,table],Segment,1)
            increment(BlocksOK[Location,table][Train,table],"tilmax",1)
            
            printM("Unheld Car "+CarToEval[1,string]+", job "+Segment)
            
            local CarTable = MainEntityList[CarToEval[1,string],table]
            MainEntityList[CarToEval[1,string],table]["hold",number] = 0
            markcar(entity(CarToEval[1,string]:toNumber()),CarTable["route",array],CarTable["step",number],0)
            
        }else{#[
            if(Segment != "rwd1"){
                
                print(CarToEval[1,string]+" "+A+" "+B+" "+C+" "+D+" "+E)
                #print(CarToEval[1,string]+" "+ApprovedMin+" "+TrainMin)
                
            }]#
        }
        
        ToEvaluate:remove(1)
        
        
    }
    
    TEC = ToEvaluate:count()
    
    while(CheckDeletions:count() & safe()){
        
        local CarTable = MainEntityList[CheckDeletions[1,string],table]
        local CarEnts = CarTable["ents",array]
        
        if(CheckDeletions[1,string]:toNumber() != 0){
        
            for(X = 1,CarEnts:count()){
            
                if(!entity(CarEnts[X,number]):isValidPhysics()){
        
                    for(Y = 1,CarEnts:count()){
                            
                        entity(CarEnts[Y,number]):propDelete()
                        
                    }
                    
                    if(CarTable["out",number] == 0){
                    
                        send(table("name" = "deleted","ent" = CarEnts[1,number]:toString()))
                        
                    }
                        
                    MainEntityList:remove(CheckDeletions[1,string])
                        
                    break
                    
                }
                
            }
            
        }
        
        CheckDeletions:remove(1)
        
    }
    
    if(HoldState == "process" & TEC == 0){
        
        HoldState = ""
        
    }
    
    while(TimersToRecheck:count() & safe()){
            
        local CarIndex = TimersToRecheck[1,string]
        local TimerEnd = MainEntityList[CarIndex,table]["timer end",number]
            
        if(TimerEnd != 0){
            
            local Index = 1
            
            while(SortedTimers[Index*2,number] < TimerEnd & SortedTimers[Index*2,number]){
        
                Index++
                
            }
            
            SortedTimers:insertString(Index*2-1,CarIndex)
            SortedTimers:insertNumber(Index*2,TimerEnd)
            
        }
        
        TimersToRecheck:remove(1)
        
    }
    
    while(LocsToMark:count() & safe()){
        
        local A = WorldMarks[LocsToMark[1,number],array]
        WorldMarkEnts:pushEntity(textworld(A[1,string],A[2,vector],A[3,number]))
        LocsToMark:remove(1)
        
    }
    
    
}

if(clk("send")){
    
    if(SignalStorage:count() & Response == Inc){
        
        Signal = SignalStorage[1,table]:clone()
        SignalStorage:remove(1)
        Inc = Response + 1
        
    }
    
    if(SignalStorage:count()){
    
        timer("send",50)
        
    }
    
}

#Sector9 = maxquota():toString()+" "+systime()

    
    
